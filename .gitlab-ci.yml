stages:
  - build
  - gitops

variables:
  AWS_REGION: "eu-north-1"
  AWS_ACCOUNT_ID: "018881300778"
  ECR_REGISTRY: "${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com"

  # Docker-in-Docker
  DOCKER_HOST: "tcp://docker:2375"
  DOCKER_TLS_CERTDIR: ""

  # Image tagging
  IMAGE_TAG: "${CI_COMMIT_SHORT_SHA}"

# Template job all services extend
.build_push_ecr_template:
  stage: build
  image: docker:24
  services:
    - name: docker:24-dind
  id_tokens:
    AWS_ID_TOKEN:
      aud: "https://gitlab.com"   # must match the trust policy "aud" you set in AWS
  before_script:
    - apk add --no-cache aws-cli jq
    - aws --version

    # Assume AWS role using GitLab OIDC token
    - |
      CREDS=$(aws sts assume-role-with-web-identity \
        --role-arn "$AWS_ROLE_ARN" \
        --role-session-name "gitlab-${CI_PROJECT_PATH_SLUG}-${CI_PIPELINE_ID}" \
        --web-identity-token "$AWS_ID_TOKEN" \
        --duration-seconds 3600)

      export AWS_ACCESS_KEY_ID=$(echo "$CREDS" | jq -r '.Credentials.AccessKeyId')
      export AWS_SECRET_ACCESS_KEY=$(echo "$CREDS" | jq -r '.Credentials.SecretAccessKey')
      export AWS_SESSION_TOKEN=$(echo "$CREDS" | jq -r '.Credentials.SessionToken')

    # Login to ECR
    - aws ecr get-login-password --region "$AWS_REGION" |
      docker login --username AWS --password-stdin "$ECR_REGISTRY"

  script:
    - echo "Building ${SERVICE_NAME} from ${SERVICE_DIR}"
    - docker build -f "${DOCKERFILE_PATH:-${SERVICE_DIR}/Dockerfile}" -t "${ECR_REGISTRY}/${ECR_REPO}:${IMAGE_TAG}" "${BUILD_CONTEXT:-.}"
    - docker push "${ECR_REGISTRY}/${ECR_REPO}:${IMAGE_TAG}"

    # Intentionally do not push moving tags (like :latest/:demo).
    # Argo CD auto-updates using argocd-image-updater by selecting the newest build tag.

include:
  - local: "src/unified-ui/ci-cd.yml"
  - local: "src/sales-module/ci-cd.yml"

# GitOps (MR-based): create a branch that bumps the deployed image tag and open a Merge Request.
# Requires a CI variable `GITLAB_BOT_TOKEN` with permission to push branches and create merge requests.
gitops_mr_unifiedui_dev:
  stage: gitops
  image: alpine:3.20
  variables:
    GIT_STRATEGY: fetch
    GIT_DEPTH: "0"
    GITOPS_BASE_BRANCH: "demo"
  rules:
    - if: '$CI_COMMIT_BRANCH == "demo" && $GITLAB_BOT_TOKEN'
      changes:
        - src/unified-ui/**/*
      when: on_success
    - when: never
  before_script:
    - apk add --no-cache git curl jq
    - git config user.email "ci-bot@mmg.global"
    - git config user.name "mmg-ci-bot"
  script:
    - |
      set -euo pipefail

      FILE="src/platform/deploy/kustomize/unifiedui/overlays/dev/kustomization.yaml"
      BRANCH="gitops/unifiedui-dev-${CI_COMMIT_SHORT_SHA}"

      echo "Preparing MR to bump Unified UI dev image tag to ${CI_COMMIT_SHORT_SHA} in ${FILE}"
      git checkout -B "${BRANCH}"
      sed -i -E "s/^([[:space:]]*newTag:).*/\\1 ${CI_COMMIT_SHORT_SHA}/" "${FILE}"

      git add "${FILE}"
      if git diff --cached --quiet; then
        echo "No change; skipping"
        exit 0
      fi

      # Do NOT use [skip ci] here; we want a verifiable MR pipeline.
      git commit -m "deploy(unifiedui-dev): ${CI_COMMIT_SHORT_SHA}"

      git push -u "https://oauth2:${GITLAB_BOT_TOKEN}@${CI_SERVER_HOST}/${CI_PROJECT_PATH}.git" "HEAD:${BRANCH}"

      MR_TITLE="Deploy unifiedui-dev: ${CI_COMMIT_SHORT_SHA}"
      MR_DESC="Automated GitOps MR generated by CI.\n\nImage tag: ${CI_COMMIT_SHORT_SHA}\nFile: ${FILE}"

      echo "Creating merge request to ${GITOPS_BASE_BRANCH}..."
      MR_JSON="$(curl --fail --silent --show-error \
        --request POST \
        --header "PRIVATE-TOKEN: ${GITLAB_BOT_TOKEN}" \
        --data-urlencode "source_branch=${BRANCH}" \
        --data-urlencode "target_branch=${GITOPS_BASE_BRANCH}" \
        --data-urlencode "title=${MR_TITLE}" \
        --data-urlencode "description=${MR_DESC}" \
        "${CI_API_V4_URL}/projects/${CI_PROJECT_ID}/merge_requests")"

      MR_URL="$(echo "${MR_JSON}" | jq -r '.web_url')"
      echo "MR created: ${MR_URL}"

# Minimal job so the MR branch has a passing pipeline (merge checks stay green).
gitops_mr_noop:
  stage: gitops
  image: alpine:3.20
  rules:
    - if: '$CI_COMMIT_BRANCH =~ /^gitops\\//'
      when: on_success
    - when: never
  script:
    - echo "GitOps MR branch pipeline OK"

# GitOps (MR-based): bump the deployed sales-module image tag (proposal-bot) and open a Merge Request.
gitops_mr_sales_dev:
  stage: gitops
  image: alpine:3.20
  variables:
    GIT_STRATEGY: fetch
    GIT_DEPTH: "0"
    GITOPS_BASE_BRANCH: "demo"
  rules:
    - if: '$CI_COMMIT_BRANCH == "demo" && $GITLAB_BOT_TOKEN'
      changes:
        - src/sales-module/**/*
        - src/shared/**/*
      when: on_success
    - when: never
  before_script:
    - apk add --no-cache git curl jq
    - git config user.email "ci-bot@mmg.global"
    - git config user.name "mmg-ci-bot"
  script:
    - |
      set -euo pipefail

      FILE="src/platform/deploy/kustomize/sales-module/overlays/dev/kustomization.yaml"
      BRANCH="gitops/sales-dev-${CI_COMMIT_SHORT_SHA}"

      echo "Preparing MR to bump sales-module dev image tag to ${CI_COMMIT_SHORT_SHA} in ${FILE}"
      git checkout -B "${BRANCH}"
      sed -i -E "s/^([[:space:]]*newTag:).*/\\1 ${CI_COMMIT_SHORT_SHA}/" "${FILE}"

      git add "${FILE}"
      if git diff --cached --quiet; then
        echo "No change; skipping"
        exit 0
      fi

      git commit -m "deploy(sales-dev): ${CI_COMMIT_SHORT_SHA}"
      git push -u "https://oauth2:${GITLAB_BOT_TOKEN}@${CI_SERVER_HOST}/${CI_PROJECT_PATH}.git" "HEAD:${BRANCH}"

      MR_TITLE="Deploy sales-dev: ${CI_COMMIT_SHORT_SHA}"
      MR_DESC="Automated GitOps MR generated by CI.\n\nImage tag: ${CI_COMMIT_SHORT_SHA}\nFile: ${FILE}"

      echo "Creating merge request to ${GITOPS_BASE_BRANCH}..."
      MR_JSON="$(curl --fail --silent --show-error \
        --request POST \
        --header "PRIVATE-TOKEN: ${GITLAB_BOT_TOKEN}" \
        --data-urlencode "source_branch=${BRANCH}" \
        --data-urlencode "target_branch=${GITOPS_BASE_BRANCH}" \
        --data-urlencode "title=${MR_TITLE}" \
        --data-urlencode "description=${MR_DESC}" \
        "${CI_API_V4_URL}/projects/${CI_PROJECT_ID}/merge_requests")"

      MR_URL="$(echo "${MR_JSON}" | jq -r '.web_url')"
      echo "MR created: ${MR_URL}"

# Deploy: apply runtime env vars (Supabase) to the cluster as a Kubernetes Secret.
# This avoids local `supabase.env` files and keeps secrets in GitLab CI/CD variables.
deploy_unifiedui_env:
  stage: gitops
  image: alpine:3.20
  variables:
    KUBECONFIG: "$CI_PROJECT_DIR/kubeconfig"
    UNIFIEDUI_NAMESPACE: "unifiedui"
    UNIFIEDUI_SECRET_NAME: "unified-ui-env"
  rules:
    - if: '$CI_COMMIT_BRANCH == "demo" && $GITLAB_BOT_TOKEN'
      when: manual
      allow_failure: false
    - when: never
  id_tokens:
    AWS_ID_TOKEN:
      aud: "https://gitlab.com"
  before_script:
    - apk add --no-cache aws-cli kubectl jq
    - aws --version
    - kubectl version --client=true
    - |
      set -euo pipefail
      CREDS=$(aws sts assume-role-with-web-identity \
        --role-arn "$AWS_ROLE_ARN" \
        --role-session-name "gitlab-${CI_PROJECT_PATH_SLUG}-${CI_PIPELINE_ID}" \
        --web-identity-token "$AWS_ID_TOKEN" \
        --duration-seconds 3600)

      export AWS_ACCESS_KEY_ID=$(echo "$CREDS" | jq -r '.Credentials.AccessKeyId')
      export AWS_SECRET_ACCESS_KEY=$(echo "$CREDS" | jq -r '.Credentials.SecretAccessKey')
      export AWS_SESSION_TOKEN=$(echo "$CREDS" | jq -r '.Credentials.SessionToken')
  script:
    - |
      set -euo pipefail

      : "${EKS_CLUSTER_NAME:?Missing EKS_CLUSTER_NAME CI/CD variable}"
      : "${AWS_REGION:?Missing AWS_REGION}"

      : "${UI_DEV_SUPABASE_URL:?Missing UI_DEV_SUPABASE_URL CI/CD variable}"
      : "${UI_DEV_SUPABASE_ANON_KEY:?Missing UI_DEV_SUPABASE_ANON_KEY CI/CD variable}"
      : "${UI_DEV_SUPABASE_SERVICE_ROLE_KEY:?Missing UI_DEV_SUPABASE_SERVICE_ROLE_KEY CI/CD variable}"

      aws eks update-kubeconfig --region "${AWS_REGION}" --name "${EKS_CLUSTER_NAME}"

      # Build an env file without echoing secrets to logs.
      ENV_FILE="$(mktemp)"
      trap 'rm -f "${ENV_FILE}"' EXIT

      printf '%s\n' \
        "ENVIRONMENT=development" \
        "PORT=3005" \
        "UI_DEV_SUPABASE_URL=${UI_DEV_SUPABASE_URL}" \
        "UI_DEV_SUPABASE_ANON_KEY=${UI_DEV_SUPABASE_ANON_KEY}" \
        "UI_DEV_SUPABASE_SERVICE_ROLE_KEY=${UI_DEV_SUPABASE_SERVICE_ROLE_KEY}" \
        > "${ENV_FILE}"

      kubectl -n "${UNIFIEDUI_NAMESPACE}" create secret generic "${UNIFIEDUI_SECRET_NAME}" \
        --from-env-file="${ENV_FILE}" \
        --dry-run=client -o yaml | kubectl apply -f -

      kubectl -n "${UNIFIEDUI_NAMESPACE}" rollout restart deployment/unified-ui || true
      echo "Updated secret ${UNIFIEDUI_NAMESPACE}/${UNIFIEDUI_SECRET_NAME}"
