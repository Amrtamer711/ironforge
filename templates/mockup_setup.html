<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Mockup Frame Setup</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      min-height: 100vh;
      padding: 20px;
    }

    .container {
      max-width: 1400px;
      margin: 0 auto;
      background: white;
      border-radius: 16px;
      box-shadow: 0 20px 60px rgba(0,0,0,0.3);
      overflow: hidden;
    }

    .header {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      padding: 30px;
      text-align: center;
    }

    .header h1 {
      font-size: 32px;
      margin-bottom: 10px;
    }

    .header p {
      opacity: 0.9;
      font-size: 16px;
    }

    .mode-toggle {
      display: flex;
      justify-content: center;
      gap: 15px;
      padding: 20px;
      background: #f8f9fa;
      border-bottom: 2px solid #e9ecef;
    }

    .mode-btn {
      padding: 12px 30px;
      border: 2px solid #667eea;
      background: white;
      color: #667eea;
      border-radius: 8px;
      font-size: 16px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.3s;
    }

    .mode-btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(102, 126, 234, 0.3);
    }

    .mode-btn.active {
      background: #667eea;
      color: white;
    }

    .content {
      padding: 30px;
    }

    .section {
      display: none;
    }

    .section.active {
      display: block;
    }

    .form-group {
      margin-bottom: 20px;
    }

    .form-group label {
      display: block;
      margin-bottom: 8px;
      font-weight: 600;
      color: #333;
    }

    .form-group select,
    .form-group input[type="file"] {
      width: 100%;
      padding: 12px;
      border: 2px solid #e9ecef;
      border-radius: 8px;
      font-size: 15px;
      transition: border-color 0.3s;
    }

    .form-group select:focus,
    .form-group input[type="file"]:focus {
      outline: none;
      border-color: #667eea;
    }

    .canvas-container {
      margin-top: 20px;
      text-align: center;
      position: relative;
    }

    #canvas {
      max-width: 100%;
      height: auto;
      border: 2px solid #e9ecef;
      border-radius: 8px;
      cursor: crosshair;
      background: #f8f9fa;
    }

    .hint {
      margin-top: 15px;
      padding: 15px;
      background: #e7f3ff;
      border-left: 4px solid #2196F3;
      border-radius: 4px;
      color: #0c5091;
      font-size: 14px;
    }

    .btn {
      padding: 12px 30px;
      border: none;
      border-radius: 8px;
      font-size: 16px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.3s;
      margin-right: 10px;
    }

    .btn-primary {
      background: #667eea;
      color: white;
    }

    .btn-primary:hover {
      background: #5568d3;
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(102, 126, 234, 0.3);
    }

    .btn-secondary {
      background: #6c757d;
      color: white;
    }

    .btn-secondary:hover {
      background: #5a6268;
    }

    .btn-danger {
      background: #dc3545;
      color: white;
    }

    .btn-danger:hover {
      background: #c82333;
    }

    .btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
      transform: none;
    }

    .button-group {
      margin-top: 20px;
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
    }

    .photo-list {
      margin-top: 20px;
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
      gap: 20px;
    }

    .photo-card {
      border: 2px solid #e9ecef;
      border-radius: 8px;
      overflow: hidden;
      transition: transform 0.3s;
    }

    .photo-card:hover {
      transform: translateY(-4px);
      box-shadow: 0 8px 16px rgba(0,0,0,0.1);
    }

    .photo-card img {
      width: 100%;
      height: 200px;
      object-fit: cover;
    }

    .photo-card-info {
      padding: 15px;
      background: #f8f9fa;
    }

    .photo-card-info h4 {
      margin-bottom: 8px;
      color: #333;
      font-size: 14px;
      word-break: break-all;
    }

    .photo-card-info button {
      width: 100%;
      margin-top: 8px;
    }

    .message {
      padding: 15px;
      border-radius: 8px;
      margin-bottom: 20px;
      display: none;
    }

    .message.success {
      background: #d4edda;
      border: 1px solid #c3e6cb;
      color: #155724;
      display: block;
    }

    .message.error {
      background: #f8d7da;
      border: 1px solid #f5c6cb;
      color: #721c24;
      display: block;
    }

    .creative-upload {
      margin-top: 20px;
    }

    .mockup-result {
      margin-top: 20px;
      text-align: center;
    }

    .mockup-result img {
      max-width: 100%;
      border-radius: 8px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.2);
    }

    .loading {
      display: none;
      text-align: center;
      padding: 40px;
    }

    .loading.active {
      display: block;
    }

    .spinner {
      border: 4px solid #f3f3f3;
      border-top: 4px solid #667eea;
      border-radius: 50%;
      width: 50px;
      height: 50px;
      animation: spin 1s linear infinite;
      margin: 0 auto 20px;
    }

    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }

    /* Toggle Switch */
    .toggle-switch {
      position: relative;
      display: inline-block;
      width: 50px;
      height: 26px;
    }

    .toggle-switch input {
      opacity: 0;
      width: 0;
      height: 0;
    }

    .toggle-slider {
      position: absolute;
      cursor: pointer;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background-color: #ccc;
      transition: 0.3s;
      border-radius: 26px;
    }

    .toggle-slider:before {
      position: absolute;
      content: "";
      height: 20px;
      width: 20px;
      left: 3px;
      bottom: 3px;
      background-color: white;
      transition: 0.3s;
      border-radius: 50%;
    }

    .toggle-switch input:checked + .toggle-slider {
      background-color: #28a745;
    }

    .toggle-switch input:checked + .toggle-slider:before {
      transform: translateX(24px);
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="header">
      <h1>Billboard Mockup Manager</h1>
      <p>Configure billboard frames and generate mockups</p>
    </div>

    <div class="mode-toggle">
      <button class="mode-btn active" onclick="switchMode('setup')">Setup Mode</button>
      <button class="mode-btn" onclick="switchMode('generate')">Generate Mode</button>
    </div>

    <div class="content">
      <div id="message" class="message"></div>

      <!-- Setup Mode -->
      <div id="setup-section" class="section active">
        <h2 style="margin-bottom: 20px;">Setup Billboard Frames</h2>

        <div class="form-group">
          <label for="setup-location">Select Location</label>
          <select id="setup-location">
            <option value="">-- Select a location --</option>
          </select>
        </div>

        <div class="form-group">
          <label for="billboard-photo">Upload Billboard Photo</label>
          <input type="file" id="billboard-photo" accept="image/*">
        </div>

        <div class="form-group" style="background: #f8f9fa; padding: 15px; border-radius: 8px;">
          <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 15px;">
            <label class="toggle-switch" style="margin: 0;">
              <input type="checkbox" id="greenscreen-toggle">
              <span class="toggle-slider"></span>
            </label>
            <label for="greenscreen-toggle" style="cursor: pointer; margin: 0;">
              <strong>Auto-detect Green Screen</strong>
              <br>
              <small style="color: #6c757d;">Automatically detect billboard frame using green screen chroma key</small>
            </label>
          </div>
          <div id="color-picker-section" style="display: none; padding-top: 10px; border-top: 1px solid #dee2e6;">
            <label for="greenscreen-color" style="display: block; margin-bottom: 5px;">
              <strong>Green Screen Color:</strong>
            </label>
            <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 10px;">
              <input type="color" id="greenscreen-color" value="#1CFF1C" style="width: 60px; height: 40px; border: 2px solid #dee2e6; border-radius: 4px; cursor: pointer;">
              <input type="text" id="greenscreen-color-hex" value="#1CFF1C" placeholder="#1CFF1C" style="flex: 1; padding: 8px; border: 1px solid #dee2e6; border-radius: 4px; font-family: monospace;">
            </div>
            <label for="color-tolerance" style="display: block; margin-bottom: 5px;">
              <strong>Color Tolerance:</strong> <span id="tolerance-value">40</span>
              <small style="color: #6c757d;">(lower = stricter, higher = more forgiving)</small>
            </label>
            <input type="range" id="color-tolerance" min="10" max="100" value="40" style="width: 100%;">
          </div>
        </div>

        <div class="canvas-container">
          <canvas id="canvas" width="1200" height="800"></canvas>
          <div class="hint" id="setup-hint">
            1. Select a location above<br>
            2. Upload a billboard photo<br>
            3. Click 4 corners of the billboard screen to define the frame<br>
            4. Click "Save Frame" to store the configuration
          </div>
        </div>

        <div class="button-group">
          <button class="btn btn-primary" id="add-frame-btn" onclick="addFrame()" disabled>Add Frame</button>
          <button class="btn btn-secondary" onclick="resetCurrentFrame()">Reset Current Frame</button>
          <button class="btn btn-primary" id="save-all-btn" onclick="saveAllFrames()" disabled>Save All Frames</button>
          <button class="btn btn-danger" onclick="clearAllFrames()">Clear All Frames</button>
        </div>
        <div id="frames-info" style="margin-top: 15px; padding: 10px; background: #e7f3ff; border-radius: 4px; display: none;">
          <strong>Frames configured: <span id="frame-count">0</span></strong>
        </div>

        <div style="margin-top: 30px; padding: 20px; background: #f8f9fa; border-radius: 8px; border: 2px dashed #dee2e6;">
          <h3 style="margin-top: 0; margin-bottom: 15px;">Test Preview</h3>
          <p style="color: #6c757d; margin-bottom: 15px;">Upload a test creative to see how it looks on the billboard (won't be saved)</p>
          <div style="display: flex; gap: 10px; align-items: center;">
            <input type="file" id="test-creative" accept="image/*" style="flex: 1;">
            <button class="btn btn-secondary" onclick="clearTestPreview()">Clear Preview</button>
          </div>
        </div>

        <h3 style="margin-top: 40px; margin-bottom: 15px;">Existing Photos</h3>
        <div id="photo-list" class="photo-list"></div>
      </div>

      <!-- Generate Mode -->
      <div id="generate-section" class="section">
        <h2 style="margin-bottom: 20px;">Generate Mockup</h2>

        <div class="form-group">
          <label for="generate-location">Select Location</label>
          <select id="generate-location">
            <option value="">-- Select a location --</option>
          </select>
        </div>

        <div class="creative-upload">
          <div class="form-group">
            <label for="creative-photo">Upload Creative/Ad Image</label>
            <input type="file" id="creative-photo" accept="image/*">
          </div>

          <div class="button-group">
            <button class="btn btn-primary" onclick="generateMockup()" id="generate-btn" disabled>Generate Mockup</button>
          </div>
        </div>

        <div id="loading" class="loading">
          <div class="spinner"></div>
          <p>Generating mockup...</p>
        </div>

        <div id="mockup-result" class="mockup-result"></div>
      </div>
    </div>
  </div>

  <script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');

    let currentMode = 'setup';
    let previewImg = null;
    let currentPhoto = null;
    let currentPoints = [];  // Points for current frame being drawn
    let allFrames = [];       // All completed frames [[x,y,x,y,x,y,x,y], ...]
    let locations = [];
    let testCreativeImg = null; // Test creative for preview

    // Canvas state
    let imgNaturalW = 0, imgNaturalH = 0;
    let drawX = 0, drawY = 0, drawW = 0, drawH = 0;
    let scale = 1;

    // Load locations
    async function loadLocations() {
      try {
        const response = await fetch('/api/mockup/locations');
        const data = await response.json();
        locations = data.locations || [];

        const setupSelect = document.getElementById('setup-location');
        const generateSelect = document.getElementById('generate-location');

        setupSelect.innerHTML = '<option value="">-- Select a location --</option>';
        generateSelect.innerHTML = '<option value="">-- Select a location --</option>';

        locations.forEach(loc => {
          setupSelect.innerHTML += `<option value="${loc.key}">${loc.name}</option>`;
          generateSelect.innerHTML += `<option value="${loc.key}">${loc.name}</option>`;
        });
      } catch (err) {
        showMessage('Failed to load locations', 'error');
      }
    }

    // Toggle color picker visibility
    document.getElementById('greenscreen-toggle').addEventListener('change', function(e) {
      const colorPickerSection = document.getElementById('color-picker-section');
      colorPickerSection.style.display = e.target.checked ? 'block' : 'none';
    });

    // Sync color picker and hex input
    document.getElementById('greenscreen-color').addEventListener('input', function(e) {
      document.getElementById('greenscreen-color-hex').value = e.target.value.toUpperCase();
    });

    document.getElementById('greenscreen-color-hex').addEventListener('input', function(e) {
      const hex = e.target.value;
      if (/^#[0-9A-F]{6}$/i.test(hex)) {
        document.getElementById('greenscreen-color').value = hex;
      }
    });

    // Update tolerance value display
    document.getElementById('color-tolerance').addEventListener('input', function(e) {
      document.getElementById('tolerance-value').textContent = e.target.value;
    });

    // Switch between modes
    function switchMode(mode) {
      currentMode = mode;

      document.querySelectorAll('.mode-btn').forEach(btn => btn.classList.remove('active'));
      event.target.classList.add('active');

      document.querySelectorAll('.section').forEach(section => section.classList.remove('active'));

      if (mode === 'setup') {
        document.getElementById('setup-section').classList.add('active');
        loadPhotoList();
      } else {
        document.getElementById('generate-section').classList.add('active');
      }
    }

    // Canvas drawing functions
    function clearCanvas() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.fillStyle = '#f8f9fa';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
    }

    function applyPerspectiveTransform(creative, points, canvasCtx) {
      // Simple perspective transform using canvas transform matrix
      // This is a basic implementation - for production use a proper perspective library
      const [tl, tr, br, bl] = points.map(pt => [drawX + pt[0] * scale, drawY + pt[1] * scale]);

      // Calculate the transformation
      canvasCtx.save();
      canvasCtx.beginPath();
      canvasCtx.moveTo(tl[0], tl[1]);
      canvasCtx.lineTo(tr[0], tr[1]);
      canvasCtx.lineTo(br[0], br[1]);
      canvasCtx.lineTo(bl[0], bl[1]);
      canvasCtx.closePath();
      canvasCtx.clip();

      // Draw creative stretched to fit the quadrilateral (simplified)
      const minX = Math.min(tl[0], tr[0], br[0], bl[0]);
      const minY = Math.min(tl[1], tr[1], br[1], bl[1]);
      const maxX = Math.max(tl[0], tr[0], br[0], bl[0]);
      const maxY = Math.max(tl[1], tr[1], br[1], bl[1]);

      canvasCtx.globalAlpha = 0.8;
      canvasCtx.drawImage(creative, minX, minY, maxX - minX, maxY - minY);
      canvasCtx.globalAlpha = 1.0;
      canvasCtx.restore();
    }

    function drawPreview() {
      clearCanvas();
      if (!previewImg) return;

      ctx.drawImage(previewImg, drawX, drawY, drawW, drawH);

      // If test creative is loaded, show it on current frame or all frames
      if (testCreativeImg) {
        const framesToPreview = currentPoints.length === 4 ? [currentPoints] : allFrames;
        framesToPreview.forEach(framePoints => {
          if (framePoints.length === 4) {
            applyPerspectiveTransform(testCreativeImg, framePoints, ctx);
          }
        });
      }

      // Draw all completed frames with grey fill and dashed edges with hard corners
      allFrames.forEach((framePoints, frameIndex) => {
        const isSelected = selectedFrameIndex === frameIndex;

        ctx.fillStyle = 'rgba(128, 128, 128, 0.3)'; // Grey semi-transparent fill
        ctx.strokeStyle = isSelected ? '#667eea' : '#333'; // Blue if selected, dark grey otherwise
        ctx.lineWidth = isSelected ? 4 : 3; // Thicker, bolder lines
        ctx.setLineDash([8, 4]); // Dashed lines
        ctx.lineCap = 'butt'; // Sharp/hard corners (not rounded)
        ctx.lineJoin = 'miter'; // Sharp corner joins

        ctx.beginPath();
        for (let i = 0; i < framePoints.length; i++) {
          const cx = drawX + framePoints[i][0] * scale;
          const cy = drawY + framePoints[i][1] * scale;
          if (i === 0) ctx.moveTo(cx, cy);
          else ctx.lineTo(cx, cy);
        }
        ctx.closePath();
        ctx.fill();
        ctx.stroke();
        ctx.setLineDash([]); // Reset dash

        // Draw small square corner markers for precision
        framePoints.forEach((pt, ptIndex) => {
          const cx = drawX + pt[0] * scale;
          const cy = drawY + pt[1] * scale;
          const markerSize = 8;

          ctx.fillStyle = isSelected ? '#667eea' : '#333';

          // Draw small square marker at corner
          ctx.fillRect(cx - markerSize/2, cy - markerSize/2, markerSize, markerSize);
        });
      });

      // Draw current frame being edited
      if (currentPoints.length > 0) {
        ctx.fillStyle = 'rgba(128, 128, 128, 0.3)'; // Grey semi-transparent fill
        ctx.strokeStyle = '#667eea'; // Blue outline for current editing
        ctx.lineWidth = 4; // Thick, bold line
        ctx.setLineDash([8, 4]); // Dashed line
        ctx.lineCap = 'butt'; // Sharp/hard corners
        ctx.lineJoin = 'miter'; // Sharp corner joins

        ctx.beginPath();
        currentPoints.forEach((pt, i) => {
          const cx = drawX + pt[0] * scale;
          const cy = drawY + pt[1] * scale;
          if (i === 0) ctx.moveTo(cx, cy);
          else ctx.lineTo(cx, cy);
        });
        if (currentPoints.length === 4) {
          ctx.closePath();
          ctx.fill();
        }
        ctx.stroke();
        ctx.setLineDash([]); // Reset dash

        // Draw small square corner markers
        currentPoints.forEach(pt => {
          const cx = drawX + pt[0] * scale;
          const cy = drawY + pt[1] * scale;
          const markerSize = 8;

          ctx.fillStyle = '#667eea';
          ctx.fillRect(cx - markerSize/2, cy - markerSize/2, markerSize, markerSize);
        });
      }
    }

    function fitImageIntoCanvas(imgW, imgH) {
      const s = Math.min(canvas.width / imgW, canvas.height / imgH);
      const w = Math.round(imgW * s);
      const h = Math.round(imgH * s);
      const x = Math.round((canvas.width - w) / 2);
      const y = Math.round((canvas.height - h) / 2);
      return { x, y, w, h, s };
    }

    // Detect green screen and extract actual corner coordinates (handles perspective/angled billboards)
    function detectGreenScreen(imageData) {
      const data = imageData.data;
      const width = imageData.width;
      const height = imageData.height;

      // Get target color from picker
      const targetHex = document.getElementById('greenscreen-color').value;
      const targetR = parseInt(targetHex.slice(1, 3), 16);
      const targetG = parseInt(targetHex.slice(3, 5), 16);
      const targetB = parseInt(targetHex.slice(5, 7), 16);

      // Color tolerance from slider
      const colorTolerance = parseInt(document.getElementById('color-tolerance').value);

      console.log(`[Green Screen] Target color: ${targetHex} (RGB: ${targetR}, ${targetG}, ${targetB}), Tolerance: ${colorTolerance}`);

      // Sample center pixel to help debug
      const centerIdx = (Math.floor(height / 2) * width + Math.floor(width / 2)) * 4;
      const sampleR = data[centerIdx];
      const sampleG = data[centerIdx + 1];
      const sampleB = data[centerIdx + 2];
      console.log(`[Green Screen] Sample pixel at center (RGB: ${sampleR}, ${sampleG}, ${sampleB})`);

      // Create binary mask of matching pixels
      const mask = new Uint8Array(width * height);
      let matchedPixelCount = 0;
      let minDistance = Infinity;
      let maxDistance = 0;

      for (let y = 0; y < height; y++) {
        for (let x = 0; x < width; x++) {
          const i = (y * width + x) * 4;
          const r = data[i];
          const g = data[i + 1];
          const b = data[i + 2];

          // Calculate Euclidean distance from target color
          const distance = Math.sqrt(
            Math.pow(r - targetR, 2) +
            Math.pow(g - targetG, 2) +
            Math.pow(b - targetB, 2)
          );

          minDistance = Math.min(minDistance, distance);
          maxDistance = Math.max(maxDistance, distance);

          // Check if within tolerance
          if (distance <= colorTolerance) {
            mask[y * width + x] = 255;
            matchedPixelCount++;
          } else {
            mask[y * width + x] = 0;
          }
        }
      }

      console.log(`[Green Screen] Distance range: ${minDistance.toFixed(1)} to ${maxDistance.toFixed(1)}`);

      console.log(`[Green Screen] Matched ${matchedPixelCount} pixels out of ${width * height} total`);
      console.log(`[Green Screen] Match percentage: ${(matchedPixelCount / (width * height) * 100).toFixed(2)}%`);

      if (matchedPixelCount < 1000) {
        console.log('[Green Screen] ❌ Not enough pixels matched (need at least 1000)');
        console.log('[Green Screen] Tip: Try increasing tolerance slider or check if green screen color matches');
        return null;
      }

      // Find contour points (edge pixels of green region)
      const contourPoints = [];

      for (let y = 1; y < height - 1; y++) {
        for (let x = 1; x < width - 1; x++) {
          const idx = y * width + x;
          if (mask[idx] === 255) {
            // Check if it's on the edge (has non-green neighbor)
            const hasNonGreenNeighbor =
              mask[idx - 1] === 0 ||           // left
              mask[idx + 1] === 0 ||           // right
              mask[idx - width] === 0 ||       // top
              mask[idx + width] === 0;         // bottom

            if (hasNonGreenNeighbor) {
              contourPoints.push([x, y]);
            }
          }
        }
      }

      console.log(`[Green Screen] Found ${contourPoints.length} contour points`);

      if (contourPoints.length < 4) {
        console.log('[Green Screen] ❌ Not enough contour points (need at least 4)');
        return null;
      }

      // Find the 4 extreme corner points from the contour
      // These formulas find corners even on angled/perspective quadrilaterals
      let topLeft = contourPoints[0];
      let topRight = contourPoints[0];
      let bottomRight = contourPoints[0];
      let bottomLeft = contourPoints[0];

      for (const pt of contourPoints) {
        const [x, y] = pt;

        // Top-left: minimize x + y
        if (x + y < topLeft[0] + topLeft[1]) topLeft = pt;

        // Top-right: maximize x - y
        if (x - y > topRight[0] - topRight[1]) topRight = pt;

        // Bottom-right: maximize x + y
        if (x + y > bottomRight[0] + bottomRight[1]) bottomRight = pt;

        // Bottom-left: minimize x - y (or maximize y - x)
        if (x - y < bottomLeft[0] - bottomLeft[1]) bottomLeft = pt;
      }

      console.log(`[Green Screen] ✓ Detected corners:`, {
        topLeft, topRight, bottomRight, bottomLeft
      });

      return [topLeft, topRight, bottomRight, bottomLeft];
    }

    // Handle photo upload
    document.getElementById('billboard-photo').addEventListener('change', function(e) {
      const file = e.target.files[0];
      if (!file) return;

      currentPhoto = file;
      const reader = new FileReader();
      reader.onload = function(event) {
        const img = new Image();
        img.onload = function() {
          previewImg = img;
          imgNaturalW = img.width;
          imgNaturalH = img.height;

          const fit = fitImageIntoCanvas(imgNaturalW, imgNaturalH);
          drawX = fit.x;
          drawY = fit.y;
          drawW = fit.w;
          drawH = fit.h;
          scale = fit.s;

          currentPoints = [];

          // Check if green screen detection is enabled
          if (document.getElementById('greenscreen-toggle').checked) {
            // Draw image to a temp canvas for pixel analysis
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = img.width;
            tempCanvas.height = img.height;
            const tempCtx = tempCanvas.getContext('2d');
            tempCtx.drawImage(img, 0, 0);
            const imageData = tempCtx.getImageData(0, 0, img.width, img.height);

            console.log('[Green Screen] Starting detection...');
            const detectedFrame = detectGreenScreen(imageData);
            if (detectedFrame) {
              currentPoints = detectedFrame;
              document.getElementById('add-frame-btn').disabled = false;
              document.getElementById('setup-hint').innerHTML =
                '✓ Green screen detected! Frame auto-configured. Drag corners to adjust or click "Add Frame" to save.';
              console.log('[Green Screen] ✓ Detection successful!');
            } else {
              document.getElementById('setup-hint').innerHTML =
                '❌ No green screen detected. Check console (F12) for details, try adjusting tolerance, or draw frame manually.';
              console.log('[Green Screen] ❌ Detection failed - see details above');
            }
          } else {
            document.getElementById('setup-hint').innerHTML =
              'Click and drag to draw a box around the billboard screen';
          }

          drawPreview();
        };
        img.src = event.target.result;
      };
      reader.readAsDataURL(file);
    });

    // Handle canvas drag for drawing boxes and editing corners
    let isDrawing = false;
    let isDraggingCorner = false;
    let isDraggingFrame = false;
    let dragFrameIndex = -1;
    let dragPointIndex = -1;
    let selectedFrameIndex = -1;
    let startX, startY;
    let dragOffsetX = 0;
    let dragOffsetY = 0;

    function getClickedCorner(x, y) {
      const hitRadius = 15;

      // Check current frame first
      if (currentPoints.length > 0) {
        for (let i = 0; i < currentPoints.length; i++) {
          const cx = drawX + currentPoints[i][0] * scale;
          const cy = drawY + currentPoints[i][1] * scale;
          const dist = Math.sqrt((x - cx) ** 2 + (y - cy) ** 2);
          if (dist < hitRadius) {
            return { frame: -1, point: i }; // -1 means current frame
          }
        }
      }

      // Check all saved frames
      for (let fi = 0; fi < allFrames.length; fi++) {
        for (let pi = 0; pi < allFrames[fi].length; pi++) {
          const cx = drawX + allFrames[fi][pi][0] * scale;
          const cy = drawY + allFrames[fi][pi][1] * scale;
          const dist = Math.sqrt((x - cx) ** 2 + (y - cy) ** 2);
          if (dist < hitRadius) {
            return { frame: fi, point: pi };
          }
        }
      }
      return null;
    }

    function isPointInFrame(x, y, framePoints) {
      // Check if point is inside polygon using ray casting
      const imgX = (x - drawX) / scale;
      const imgY = (y - drawY) / scale;

      let inside = false;
      for (let i = 0, j = framePoints.length - 1; i < framePoints.length; j = i++) {
        const xi = framePoints[i][0], yi = framePoints[i][1];
        const xj = framePoints[j][0], yj = framePoints[j][1];

        const intersect = ((yi > imgY) !== (yj > imgY))
            && (imgX < (xj - xi) * (imgY - yi) / (yj - yi) + xi);
        if (intersect) inside = !inside;
      }
      return inside;
    }

    function getHoveredFrame(x, y) {
      // Check current frame first
      if (currentPoints.length === 4 && isPointInFrame(x, y, currentPoints)) {
        return -1;
      }

      // Check all saved frames
      for (let fi = allFrames.length - 1; fi >= 0; fi--) {
        if (isPointInFrame(x, y, allFrames[fi])) {
          return fi;
        }
      }
      return null;
    }

    canvas.addEventListener('mousedown', function(e) {
      if (currentMode !== 'setup' || !previewImg) return;

      const rect = canvas.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;

      // Check if clicking on a corner (highest priority)
      const corner = getClickedCorner(x, y);
      if (corner) {
        isDraggingCorner = true;
        dragFrameIndex = corner.frame;
        dragPointIndex = corner.point;
        if (dragFrameIndex >= 0) {
          selectedFrameIndex = dragFrameIndex;
        }
        drawPreview();
        return;
      }

      // Check if clicking inside a frame (to drag entire frame)
      const hoveredFrame = getHoveredFrame(x, y);
      if (hoveredFrame !== null) {
        isDraggingFrame = true;
        dragFrameIndex = hoveredFrame;
        selectedFrameIndex = hoveredFrame;
        startX = x;
        startY = y;
        canvas.style.cursor = 'move';
        drawPreview();
        return;
      }

      // Check if click is inside image
      if (x < drawX || y < drawY || x > drawX + drawW || y > drawY + drawH) return;

      // Start drawing new box
      isDrawing = true;
      startX = x;
      startY = y;
      selectedFrameIndex = -1;
    });

    canvas.addEventListener('mousemove', function(e) {
      if (currentMode !== 'setup' || !previewImg) return;

      const rect = canvas.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;

      // Dragging a corner
      if (isDraggingCorner) {
        const ix = (x - drawX) / scale;
        const iy = (y - drawY) / scale;

        if (dragFrameIndex === -1) {
          // Editing current frame
          currentPoints[dragPointIndex] = [Math.round(ix), Math.round(iy)];
        } else {
          // Editing saved frame
          allFrames[dragFrameIndex][dragPointIndex] = [Math.round(ix), Math.round(iy)];
        }
        drawPreview();
        return;
      }

      // Dragging entire frame
      if (isDraggingFrame) {
        const deltaX = (x - startX) / scale;
        const deltaY = (y - startY) / scale;

        if (dragFrameIndex === -1) {
          // Move current frame
          currentPoints = currentPoints.map(pt => [
            Math.round(pt[0] + deltaX),
            Math.round(pt[1] + deltaY)
          ]);
        } else {
          // Move saved frame
          allFrames[dragFrameIndex] = allFrames[dragFrameIndex].map(pt => [
            Math.round(pt[0] + deltaX),
            Math.round(pt[1] + deltaY)
          ]);
        }

        startX = x;
        startY = y;
        drawPreview();
        return;
      }

      // Drawing new box
      if (isDrawing) {
        drawPreview();
        const ctx = canvas.getContext('2d');

        // Draw grey fill
        ctx.fillStyle = 'rgba(128, 128, 128, 0.3)';
        const width = x - startX;
        const height = y - startY;
        ctx.fillRect(startX, startY, width, height);

        // Draw dashed outline with hard corners
        ctx.strokeStyle = '#667eea';
        ctx.lineWidth = 4;
        ctx.setLineDash([8, 4]);
        ctx.lineCap = 'butt';
        ctx.lineJoin = 'miter';
        ctx.strokeRect(startX, startY, width, height);
        ctx.setLineDash([]);
        return;
      }

      // Update cursor based on hover state
      const hoveredFrame = getHoveredFrame(x, y);
      const hoveredCorner = getClickedCorner(x, y);

      if (hoveredCorner) {
        canvas.style.cursor = 'pointer';
      } else if (hoveredFrame !== null) {
        canvas.style.cursor = 'move';
      } else {
        canvas.style.cursor = 'crosshair';
      }
    });

    canvas.addEventListener('mouseup', function(e) {
      if (currentMode !== 'setup' || !previewImg) return;

      if (isDraggingCorner) {
        isDraggingCorner = false;
        dragFrameIndex = -1;
        dragPointIndex = -1;
        canvas.style.cursor = 'crosshair';
        drawPreview();
        return;
      }

      if (isDraggingFrame) {
        isDraggingFrame = false;
        dragFrameIndex = -1;
        canvas.style.cursor = 'crosshair';
        drawPreview();
        return;
      }

      if (!isDrawing) return;

      const rect = canvas.getBoundingClientRect();
      const endX = e.clientX - rect.left;
      const endY = e.clientY - rect.top;

      const topLeftX = (Math.min(startX, endX) - drawX) / scale;
      const topLeftY = (Math.min(startY, endY) - drawY) / scale;
      const bottomRightX = (Math.max(startX, endX) - drawX) / scale;
      const bottomRightY = (Math.max(startY, endY) - drawY) / scale;

      currentPoints = [
        [Math.round(topLeftX), Math.round(topLeftY)],
        [Math.round(bottomRightX), Math.round(topLeftY)],
        [Math.round(bottomRightX), Math.round(bottomRightY)],
        [Math.round(topLeftX), Math.round(bottomRightY)]
      ];

      isDrawing = false;
      drawPreview();

      document.getElementById('add-frame-btn').disabled = false;
      document.getElementById('setup-hint').innerHTML =
        '✓ Frame drawn! Drag corners to adjust, or drag inside to move. Click "Add Frame" to save.';
    });

    // Handle test creative upload
    document.getElementById('test-creative').addEventListener('change', function(e) {
      const file = e.target.files[0];
      if (!file) return;

      const reader = new FileReader();
      reader.onload = function(event) {
        const img = new Image();
        img.onload = function() {
          testCreativeImg = img;
          drawPreview();
          showMessage('Test creative loaded! It will appear on your frames.', 'success');
        };
        img.src = event.target.result;
      };
      reader.readAsDataURL(file);
    });

    // Clear test preview
    function clearTestPreview() {
      testCreativeImg = null;
      document.getElementById('test-creative').value = '';
      drawPreview();
      showMessage('Test preview cleared', 'success');
    }

    // Add current frame to allFrames
    function addFrame() {
      if (currentPoints.length !== 4) {
        showMessage('Please select 4 corner points', 'error');
        return;
      }

      allFrames.push([...currentPoints]);
      currentPoints = [];
      document.getElementById('add-frame-btn').disabled = true;
      document.getElementById('save-all-btn').disabled = false;
      document.getElementById('frames-info').style.display = 'block';
      document.getElementById('frame-count').textContent = allFrames.length;

      document.getElementById('setup-hint').innerHTML =
        `✓ Frame ${allFrames.length} added! Draw another box for more frames, or "Save All Frames" when done.`;

      drawPreview();
    }

    // Reset current frame
    function resetCurrentFrame() {
      currentPoints = [];
      drawPreview();
      document.getElementById('add-frame-btn').disabled = true;
      if (previewImg) {
        if (allFrames.length > 0) {
          document.getElementById('setup-hint').innerHTML =
            `${allFrames.length} frame(s) saved. Draw another box for another frame, or "Save All Frames" when done.`;
        } else {
          document.getElementById('setup-hint').innerHTML =
            'Click and drag to draw a box around the billboard screen';
        }
      }
    }

    // Clear all frames
    function clearAllFrames() {
      if (allFrames.length === 0 && currentPoints.length === 0) return;
      if (!confirm('Clear all frames? This will reset your work.')) return;

      allFrames = [];
      currentPoints = [];
      document.getElementById('add-frame-btn').disabled = true;
      document.getElementById('save-all-btn').disabled = true;
      document.getElementById('frames-info').style.display = 'none';
      document.getElementById('frame-count').textContent = '0';
      drawPreview();

      if (previewImg) {
        document.getElementById('setup-hint').innerHTML =
          'Click and drag to draw a box around the billboard screen';
      }
    }

    // Save all frames
    async function saveAllFrames() {
      const locationKey = document.getElementById('setup-location').value;
      if (!locationKey) {
        showMessage('Please select a location', 'error');
        return;
      }

      // Add current frame if it has 4 points
      if (currentPoints.length === 4) {
        allFrames.push([...currentPoints]);
        currentPoints = [];
      }

      if (allFrames.length === 0) {
        showMessage('Please add at least one frame', 'error');
        return;
      }

      if (!currentPhoto) {
        showMessage('Please upload a photo', 'error');
        return;
      }

      const formData = new FormData();
      formData.append('location_key', locationKey);
      formData.append('photo', currentPhoto);
      formData.append('frames_data', JSON.stringify(allFrames));

      try {
        const response = await fetch('/api/mockup/save-frame', {
          method: 'POST',
          body: formData
        });

        const result = await response.json();

        if (response.ok) {
          showMessage(`Saved ${allFrames.length} frame(s) successfully!`, 'success');
          clearAllFrames();
          document.getElementById('billboard-photo').value = '';
          previewImg = null;
          currentPhoto = null;
          loadPhotoList();
        } else {
          showMessage(result.error || 'Failed to save frames', 'error');
        }
      } catch (err) {
        showMessage('Network error: ' + err.message, 'error');
      }
    }

    // Load photo list
    async function loadPhotoList() {
      const locationKey = document.getElementById('setup-location').value;
      if (!locationKey) {
        document.getElementById('photo-list').innerHTML = '';
        return;
      }

      try {
        const response = await fetch(`/api/mockup/photos/${locationKey}`);
        const data = await response.json();

        const photoList = document.getElementById('photo-list');
        if (!data.photos || data.photos.length === 0) {
          photoList.innerHTML = '<p style="grid-column: 1/-1; text-align: center; color: #6c757d;">No photos configured for this location yet.</p>';
          return;
        }

        photoList.innerHTML = data.photos.map(photo => `
          <div class="photo-card">
            <img src="/api/mockup/photo/${locationKey}/${photo}" alt="${photo}">
            <div class="photo-card-info">
              <h4>${photo}</h4>
              <button class="btn btn-danger btn-sm" onclick="deletePhoto('${locationKey}', '${photo}')">Delete</button>
            </div>
          </div>
        `).join('');
      } catch (err) {
        showMessage('Failed to load photos', 'error');
      }
    }

    // Delete photo
    async function deletePhoto(locationKey, photoFilename) {
      if (!confirm(`Delete ${photoFilename}?`)) return;

      try {
        const response = await fetch(`/api/mockup/photo/${locationKey}/${photoFilename}`, {
          method: 'DELETE'
        });

        if (response.ok) {
          showMessage('Photo deleted successfully', 'success');
          loadPhotoList();
        } else {
          const result = await response.json();
          showMessage(result.error || 'Failed to delete photo', 'error');
        }
      } catch (err) {
        showMessage('Network error: ' + err.message, 'error');
      }
    }

    // Generate mockup
    async function generateMockup() {
      const locationKey = document.getElementById('generate-location').value;
      const creativeFile = document.getElementById('creative-photo').files[0];

      if (!locationKey || !creativeFile) {
        showMessage('Please select location and creative image', 'error');
        return;
      }

      const formData = new FormData();
      formData.append('location_key', locationKey);
      formData.append('creative', creativeFile);

      document.getElementById('loading').classList.add('active');
      document.getElementById('generate-btn').disabled = true;
      document.getElementById('mockup-result').innerHTML = '';

      try {
        const response = await fetch('/api/mockup/generate', {
          method: 'POST',
          body: formData
        });

        if (response.ok) {
          const blob = await response.blob();
          const url = URL.createObjectURL(blob);

          document.getElementById('mockup-result').innerHTML = `
            <h3 style="margin-bottom: 15px;">Generated Mockup</h3>
            <img src="${url}" alt="Generated Mockup">
            <div style="margin-top: 15px;">
              <a href="${url}" download="mockup.jpg" class="btn btn-primary">Download Mockup</a>
            </div>
          `;
          showMessage('Mockup generated successfully!', 'success');
        } else {
          const result = await response.json();
          showMessage(result.error || 'Failed to generate mockup', 'error');
        }
      } catch (err) {
        showMessage('Network error: ' + err.message, 'error');
      } finally {
        document.getElementById('loading').classList.remove('active');
        document.getElementById('generate-btn').disabled = false;
      }
    }

    // Show message
    function showMessage(text, type) {
      const messageEl = document.getElementById('message');
      messageEl.textContent = text;
      messageEl.className = `message ${type}`;

      setTimeout(() => {
        messageEl.className = 'message';
      }, 5000);
    }

    // Event listeners
    document.getElementById('setup-location').addEventListener('change', loadPhotoList);

    document.getElementById('creative-photo').addEventListener('change', function() {
      document.getElementById('generate-btn').disabled = !this.files[0];
    });

    // Initialize
    loadLocations();
  </script>
</body>
</html>
