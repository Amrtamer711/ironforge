<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Mockup Frame Setup</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      min-height: 100vh;
      padding: 20px;
    }

    .container {
      max-width: 1400px;
      margin: 0 auto;
      background: white;
      border-radius: 16px;
      box-shadow: 0 20px 60px rgba(0,0,0,0.3);
      overflow: hidden;
    }

    .header {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      padding: 30px;
      text-align: center;
    }

    .header h1 {
      font-size: 32px;
      margin-bottom: 10px;
    }

    .header p {
      opacity: 0.9;
      font-size: 16px;
    }

    .mode-toggle {
      display: flex;
      justify-content: center;
      gap: 15px;
      padding: 20px;
      background: #f8f9fa;
      border-bottom: 2px solid #e9ecef;
    }

    .mode-btn {
      padding: 12px 30px;
      border: 2px solid #667eea;
      background: white;
      color: #667eea;
      border-radius: 8px;
      font-size: 16px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.3s;
    }

    .mode-btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(102, 126, 234, 0.3);
    }

    .mode-btn.active {
      background: #667eea;
      color: white;
    }

    .content {
      padding: 30px;
    }

    .section {
      display: none;
    }

    .section.active {
      display: block;
    }

    .form-group {
      margin-bottom: 20px;
    }

    .form-group label {
      display: block;
      margin-bottom: 8px;
      font-weight: 600;
      color: #333;
    }

    .form-group select,
    .form-group input[type="file"] {
      width: 100%;
      padding: 12px;
      border: 2px solid #e9ecef;
      border-radius: 8px;
      font-size: 15px;
      transition: border-color 0.3s;
    }

    .form-group select:focus,
    .form-group input[type="file"]:focus {
      outline: none;
      border-color: #667eea;
    }

    /* Make range sliders smaller and more compact */
    input[type="range"] {
      height: 6px;
      -webkit-appearance: none;
      appearance: none;
      background: #e9ecef;
      border-radius: 3px;
      outline: none;
    }

    input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 16px;
      height: 16px;
      background: #667eea;
      border-radius: 50%;
      cursor: pointer;
      transition: background 0.2s;
    }

    input[type="range"]::-webkit-slider-thumb:hover {
      background: #5568d3;
    }

    input[type="range"]::-moz-range-thumb {
      width: 16px;
      height: 16px;
      background: #667eea;
      border-radius: 50%;
      cursor: pointer;
      border: none;
      transition: background 0.2s;
    }

    input[type="range"]::-moz-range-thumb:hover {
      background: #5568d3;
    }

    .canvas-container {
      margin-top: 20px;
      text-align: center;
      position: relative;
    }

    #canvas {
      max-width: 100%;
      height: auto;
      border: 2px solid #e9ecef;
      border-radius: 8px;
      cursor: crosshair;
      background: #f8f9fa;
    }

    .hint {
      margin-top: 15px;
      padding: 15px;
      background: #e7f3ff;
      border-left: 4px solid #2196F3;
      border-radius: 4px;
      color: #0c5091;
      font-size: 14px;
    }

    .btn {
      padding: 12px 30px;
      border: none;
      border-radius: 8px;
      font-size: 16px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.3s;
      margin-right: 10px;
    }

    .btn-primary {
      background: #667eea;
      color: white;
    }

    .btn-primary:hover {
      background: #5568d3;
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(102, 126, 234, 0.3);
    }

    .btn-secondary {
      background: #6c757d;
      color: white;
    }

    .btn-secondary:hover {
      background: #5a6268;
    }

    .btn-danger {
      background: #dc3545;
      color: white;
    }

    .btn-danger:hover {
      background: #c82333;
    }

    .btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
      transform: none;
    }

    .button-group {
      margin-top: 20px;
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
    }

    .photo-list {
      margin-top: 20px;
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
      gap: 20px;
    }

    .photo-card {
      border: 2px solid #e9ecef;
      border-radius: 8px;
      overflow: hidden;
      transition: transform 0.3s;
    }

    .photo-card:hover {
      transform: translateY(-4px);
      box-shadow: 0 8px 16px rgba(0,0,0,0.1);
    }

    .photo-card img {
      width: 100%;
      height: 200px;
      object-fit: cover;
    }

    .photo-card-info {
      padding: 15px;
      background: #f8f9fa;
    }

    .photo-card-info h4 {
      margin-bottom: 8px;
      color: #333;
      font-size: 14px;
      word-break: break-all;
    }

    .photo-card-info button {
      width: 100%;
      margin-top: 8px;
    }

    .message {
      padding: 15px;
      border-radius: 8px;
      margin-bottom: 20px;
      display: none;
    }

    .message.success {
      background: #d4edda;
      border: 1px solid #c3e6cb;
      color: #155724;
      display: block;
    }

    .message.error {
      background: #f8d7da;
      border: 1px solid #f5c6cb;
      color: #721c24;
      display: block;
    }

    .creative-upload {
      margin-top: 20px;
    }

    .mockup-result {
      margin-top: 20px;
      text-align: center;
    }

    .mockup-result img {
      max-width: 100%;
      border-radius: 8px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.2);
    }

    .loading {
      display: none;
      text-align: center;
      padding: 40px;
    }

    .loading.active {
      display: block;
    }

    .spinner {
      border: 4px solid #f3f3f3;
      border-top: 4px solid #667eea;
      border-radius: 50%;
      width: 50px;
      height: 50px;
      animation: spin 1s linear infinite;
      margin: 0 auto 20px;
    }

    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }

    /* Toggle Switch */
    .toggle-switch {
      position: relative;
      display: inline-block;
      width: 50px;
      height: 26px;
    }

    .toggle-switch input {
      opacity: 0;
      width: 0;
      height: 0;
    }

    .toggle-slider {
      position: absolute;
      cursor: pointer;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background-color: #ccc;
      transition: 0.3s;
      border-radius: 26px;
    }

    .toggle-slider:before {
      position: absolute;
      content: "";
      height: 20px;
      width: 20px;
      left: 3px;
      bottom: 3px;
      background-color: white;
      transition: 0.3s;
      border-radius: 50%;
    }

    .toggle-switch input:checked + .toggle-slider {
      background-color: #28a745;
    }

    .toggle-switch input:checked + .toggle-slider:before {
      transform: translateX(24px);
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="header">
      <h1>Billboard Mockup Manager</h1>
      <p>Configure billboard frames and generate mockups</p>
    </div>

    <div class="mode-toggle">
      <button class="mode-btn active" onclick="switchMode('setup')">Setup Mode</button>
      <button class="mode-btn" onclick="switchMode('generate')">Generate Mode</button>
    </div>

    <div class="content">
      <div id="message" class="message"></div>

      <!-- Setup Mode -->
      <div id="setup-section" class="section active">
        <h2 style="margin-bottom: 20px;">Setup Billboard Frames</h2>

        <div class="form-group">
          <label for="setup-location">Select Location</label>
          <select id="setup-location">
            <option value="">-- Select a location --</option>
          </select>
        </div>

        <div class="form-group">
          <label for="setup-time-of-day">Time of Day</label>
          <select id="setup-time-of-day">
            <option value="all">All (Default)</option>
            <option value="day">Day</option>
            <option value="night">Night</option>
          </select>
          <small style="color: #6c757d; display: block; margin-top: 5px;">Select the time of day for this photo</small>
        </div>

        <div class="form-group">
          <label for="setup-finish">Billboard Finish</label>
          <select id="setup-finish">
            <option value="all">All (Default)</option>
            <option value="gold">Gold</option>
            <option value="silver">Silver</option>
          </select>
          <small style="color: #6c757d; display: block; margin-top: 5px;">Select the billboard frame finish</small>
        </div>

        <div class="form-group">
          <label for="billboard-photo">Upload Billboard Photo</label>
          <input type="file" id="billboard-photo" accept="image/*">
        </div>

        <div class="form-group" style="background: #f8f9fa; padding: 15px; border-radius: 8px;">
          <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 15px;">
            <label class="toggle-switch" style="margin: 0;">
              <input type="checkbox" id="greenscreen-toggle">
              <span class="toggle-slider"></span>
            </label>
            <label for="greenscreen-toggle" style="cursor: pointer; margin: 0;">
              <strong>Auto-detect Green Screen</strong>
              <br>
              <small style="color: #6c757d;">Automatically detect billboard frame using green screen chroma key</small>
            </label>
          </div>
          <div id="color-picker-section" style="display: none; padding-top: 10px; border-top: 1px solid #dee2e6;">
            <label for="greenscreen-color" style="display: block; margin-bottom: 5px;">
              <strong>Green Screen Color:</strong>
            </label>
            <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 10px;">
              <input type="color" id="greenscreen-color" value="#1CFF1C" style="width: 60px; height: 40px; border: 2px solid #dee2e6; border-radius: 4px; cursor: pointer;">
              <input type="text" id="greenscreen-color-hex" value="#1CFF1C" placeholder="#1CFF1C" style="flex: 1; padding: 8px; border: 1px solid #dee2e6; border-radius: 4px; font-family: monospace;">
            </div>
            <small style="color: #6c757d; display: block; margin-top: -5px; margin-bottom: 10px;">
              üí° <strong>Tip:</strong> Hold Shift and click on the green screen in the preview to auto-detect and set the exact color
            </small>
            <label for="color-tolerance" style="display: block; margin-bottom: 5px;">
              <strong>Color Tolerance:</strong> <span id="tolerance-value">40</span>
              <small style="color: #6c757d;">(lower = stricter, higher = more forgiving)</small>
            </label>
            <input type="range" id="color-tolerance" min="10" max="100" value="40" style="width: 100%;">

            <button type="button" id="detect-greenscreen-btn" class="btn btn-primary" style="width: 100%; margin-top: 15px;" disabled>
              üîç Detect Green Screen Now
            </button>
          </div>
        </div>

        <div class="canvas-container">
          <canvas id="canvas" width="1200" height="800"></canvas>
          <div class="hint" id="setup-hint">
            1. Select a location above<br>
            2. Upload a billboard photo<br>
            3. Click 4 corners of the billboard screen to define the frame<br>
            4. Click "Save Frame" to store the configuration
          </div>
        </div>

        <div class="form-group" style="background: #fff3cd; padding: 15px; border-radius: 8px; border-left: 4px solid #ffc107; margin-top: 15px;">
          <h3 style="margin-bottom: 15px; font-size: 16px; color: #856404;">üé® Photo Enhancement Config (Saved per photo)</h3>

          <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px;">
            <div>
              <label for="config-brightness" style="display: block; margin-bottom: 5px;">
                <strong>Brightness:</strong> <span id="brightness-value">100</span>%
              </label>
              <input type="range" id="config-brightness" min="50" max="200" value="100" style="width: 100%;">
            </div>

            <div>
              <label for="config-contrast" style="display: block; margin-bottom: 5px;">
                <strong>Contrast:</strong> <span id="contrast-value">100</span>%
              </label>
              <input type="range" id="config-contrast" min="50" max="200" value="100" style="width: 100%;">
            </div>

            <div>
              <label for="config-saturation" style="display: block; margin-bottom: 5px;">
                <strong>Saturation:</strong> <span id="saturation-value">100</span>%
              </label>
              <input type="range" id="config-saturation" min="0" max="200" value="100" style="width: 100%;">
            </div>

            <div>
              <label for="config-depth-multiplier" style="display: block; margin-bottom: 5px;">
                <strong>Depth Perception:</strong> <span id="depth-value">15</span>x
              </label>
              <input type="range" id="config-depth-multiplier" min="5" max="30" value="15" style="width: 100%;">
              <small style="color: #6c757d; display: block; margin-top: 2px;">How much to compensate for billboard perspective</small>
            </div>

            <div>
              <label for="config-blur-strength" style="display: block; margin-bottom: 5px;">
                <strong>Edge Blur:</strong> <span id="blur-value">8</span>px
              </label>
              <input type="range" id="config-blur-strength" min="2" max="20" value="8" style="width: 100%;">
              <small style="color: #6c757d; display: block; margin-top: 2px;">Smoothness of mockup edges</small>
            </div>

            <div>
              <label for="config-overlay-opacity" style="display: block; margin-bottom: 5px;">
                <strong>Overlay Opacity:</strong> <span id="overlay-value">0</span>%
              </label>
              <input type="range" id="config-overlay-opacity" min="0" max="50" value="0" style="width: 100%;">
              <small style="color: #6c757d; display: block; margin-top: 2px;">Billboard photo overlay on top of creative for realism</small>
            </div>

            <div>
              <label for="config-shadow-intensity" style="display: block; margin-bottom: 5px;">
                <strong>Shadow Intensity:</strong> <span id="shadow-value">0</span>%
              </label>
              <input type="range" id="config-shadow-intensity" min="0" max="100" value="0" style="width: 100%;">
              <small style="color: #6c757d; display: block; margin-top: 2px;">Darken edges for depth simulation</small>
            </div>

            <div>
              <label for="config-lighting-adjustment" style="display: block; margin-bottom: 5px;">
                <strong>Lighting Match:</strong> <span id="lighting-value">0</span>%
              </label>
              <input type="range" id="config-lighting-adjustment" min="-50" max="50" value="0" style="width: 100%;">
              <small style="color: #6c757d; display: block; margin-top: 2px;">Adjust creative brightness to match billboard lighting</small>
            </div>

            <div>
              <label for="config-color-temperature" style="display: block; margin-bottom: 5px;">
                <strong>Color Temperature:</strong> <span id="temperature-value">0</span>
              </label>
              <input type="range" id="config-color-temperature" min="-50" max="50" value="0" style="width: 100%;">
              <small style="color: #6c757d; display: block; margin-top: 2px;">Warm (positive) or cool (negative) color shift</small>
            </div>

            <div>
              <label for="config-vignette" style="display: block; margin-bottom: 5px;">
                <strong>Vignette:</strong> <span id="vignette-value">0</span>%
              </label>
              <input type="range" id="config-vignette" min="0" max="100" value="0" style="width: 100%;">
              <small style="color: #6c757d; display: block; margin-top: 2px;">Darken corners for natural look</small>
            </div>
          </div>

          <small style="color: #856404; display: block; margin-top: 10px; text-align: center;">
            ‚ÑπÔ∏è These settings will be saved with the billboard frame and applied during mockup generation
          </small>
        </div>

        <div id="test-preview-section" style="display: none; margin-top: 15px; padding: 15px; background: #e3f2fd; border-radius: 8px; border-left: 4px solid #2196f3;">
          <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 10px;">
            <label class="toggle-switch" style="margin: 0;">
              <input type="checkbox" id="test-preview-toggle">
              <span class="toggle-slider"></span>
            </label>
            <label for="test-preview-toggle" style="cursor: pointer; margin: 0; flex: 1;">
              <strong>üß™ Test Preview Mode</strong>
              <br>
              <small style="color: #1565c0;">Preview creative on current frame before adding it</small>
            </label>
          </div>

          <div id="test-preview-upload" style="display: none;">
            <label for="test-creative-upload" style="display: block; margin-bottom: 8px;">
              <strong>Upload Test Creative:</strong>
            </label>
            <input type="file" id="test-creative-upload" accept="image/*" style="width: 100%;">
            <small style="color: #1565c0; display: block; margin-top: 5px;">
              Preview will show on the blue frame with all config settings applied
            </small>
          </div>
        </div>

        <div class="button-group">
          <button class="btn btn-primary" id="add-frame-btn" onclick="addFrame()" disabled>Add Frame</button>
          <button class="btn btn-secondary" onclick="resetCurrentFrame()">Reset Current Frame</button>
          <button class="btn btn-primary" id="save-all-btn" onclick="saveAllFrames()" disabled>Save All Frames</button>
          <button class="btn btn-danger" onclick="clearAllFrames()">Clear All Frames</button>
        </div>
        <div id="frames-info" style="margin-top: 15px; padding: 10px; background: #e7f3ff; border-radius: 4px; display: none;">
          <strong>Frames configured: <span id="frame-count">0</span></strong>
        </div>

        <h3 style="margin-top: 40px; margin-bottom: 15px;">Existing Photos</h3>
        <div id="photo-list" class="photo-list"></div>
      </div>

      <!-- Generate Mode -->
      <div id="generate-section" class="section">
        <h2 style="margin-bottom: 20px;">Generate Mockup</h2>

        <div class="form-group">
          <label for="generate-location">Select Location</label>
          <select id="generate-location">
            <option value="">-- Select a location --</option>
          </select>
        </div>

        <div class="form-group">
          <label for="generate-time-of-day">Time of Day</label>
          <select id="generate-time-of-day">
            <option value="all">All (Default)</option>
            <option value="day">Day</option>
            <option value="night">Night</option>
          </select>
        </div>

        <div class="form-group">
          <label for="generate-finish">Billboard Finish</label>
          <select id="generate-finish">
            <option value="all">All (Default)</option>
            <option value="gold">Gold</option>
            <option value="silver">Silver</option>
          </select>
        </div>

        <div class="creative-upload">
          <div class="form-group">
            <label for="creative-photo">Upload Creative/Ad Image</label>
            <input type="file" id="creative-photo" accept="image/*">
            <small style="color: #6c757d; display: block; margin-top: 5px;">Upload your own creative image</small>
          </div>

          <div style="text-align: center; margin: 20px 0; color: #6c757d; font-weight: 500;">
            ‚Äî OR ‚Äî
          </div>

          <div class="form-group">
            <label for="ai-creative-prompt">AI-Generated Creative (Describe what you want)</label>
            <textarea
              id="ai-creative-prompt"
              placeholder="e.g., luxury watch ad with gold typography on dark background, professional and elegant"
              rows="3"
              style="width: 100%; padding: 10px; border: 1px solid #dee2e6; border-radius: 4px; font-family: inherit; resize: vertical;"
            ></textarea>
            <small style="color: #6c757d; display: block; margin-top: 5px;">
              üí° The AI will generate a billboard creative based on your description (no upload needed)
            </small>
          </div>

          <div class="button-group">
            <button class="btn btn-primary" onclick="generateMockup()" id="generate-btn" disabled>Generate Mockup</button>
          </div>
        </div>

        <div id="loading" class="loading">
          <div class="spinner"></div>
          <p>Generating mockup...</p>
        </div>

        <div id="mockup-result" class="mockup-result"></div>
      </div>
    </div>
  </div>

  <script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');

    let currentMode = 'setup';
    let previewImg = null;
    let currentPhoto = null;
    let currentPoints = [];  // Points for current frame being drawn
    let allFrames = [];       // All completed frames [[x,y,x,y,x,y,x,y], ...]
    let locations = [];
    let testCreativeImg = null; // Test creative for preview
    let testPreviewMode = false; // Test preview mode flag

    // Canvas state
    let imgNaturalW = 0, imgNaturalH = 0;
    let drawX = 0, drawY = 0, drawW = 0, drawH = 0;
    let scale = 1;

    // Load locations
    async function loadLocations() {
      try {
        const response = await fetch('/api/mockup/locations');
        const data = await response.json();
        locations = data.locations || [];

        const setupSelect = document.getElementById('setup-location');
        const generateSelect = document.getElementById('generate-location');

        setupSelect.innerHTML = '<option value="">-- Select a location --</option>';
        generateSelect.innerHTML = '<option value="">-- Select a location --</option>';

        locations.forEach(loc => {
          setupSelect.innerHTML += `<option value="${loc.key}">${loc.name}</option>`;
          generateSelect.innerHTML += `<option value="${loc.key}">${loc.name}</option>`;
        });
      } catch (err) {
        showMessage('Failed to load locations', 'error');
      }
    }

    // Toggle color picker visibility
    document.getElementById('greenscreen-toggle').addEventListener('change', function(e) {
      const colorPickerSection = document.getElementById('color-picker-section');
      colorPickerSection.style.display = e.target.checked ? 'block' : 'none';

      // Enable/disable detect button based on toggle and if image is loaded
      const detectBtn = document.getElementById('detect-greenscreen-btn');
      detectBtn.disabled = !e.target.checked || !previewImg;
    });

    // Sync color picker and hex input
    document.getElementById('greenscreen-color').addEventListener('input', function(e) {
      document.getElementById('greenscreen-color-hex').value = e.target.value.toUpperCase();
    });

    document.getElementById('greenscreen-color-hex').addEventListener('input', function(e) {
      const hex = e.target.value;
      if (/^#[0-9A-F]{6}$/i.test(hex)) {
        document.getElementById('greenscreen-color').value = hex;
      }
    });

    // Update tolerance value display
    document.getElementById('color-tolerance').addEventListener('input', function(e) {
      document.getElementById('tolerance-value').textContent = e.target.value;
    });

    // Update config value displays and redraw preview if in test mode
    document.getElementById('config-brightness').addEventListener('input', function(e) {
      document.getElementById('brightness-value').textContent = e.target.value;
      if (testPreviewMode && testCreativeImg) drawPreview();
    });
    document.getElementById('config-contrast').addEventListener('input', function(e) {
      document.getElementById('contrast-value').textContent = e.target.value;
      if (testPreviewMode && testCreativeImg) drawPreview();
    });
    document.getElementById('config-saturation').addEventListener('input', function(e) {
      document.getElementById('saturation-value').textContent = e.target.value;
      if (testPreviewMode && testCreativeImg) drawPreview();
    });
    document.getElementById('config-depth-multiplier').addEventListener('input', function(e) {
      document.getElementById('depth-value').textContent = e.target.value;
    });
    document.getElementById('config-blur-strength').addEventListener('input', function(e) {
      document.getElementById('blur-value').textContent = e.target.value;
    });
    document.getElementById('config-overlay-opacity').addEventListener('input', function(e) {
      document.getElementById('overlay-value').textContent = e.target.value;
    });
    document.getElementById('config-shadow-intensity').addEventListener('input', function(e) {
      document.getElementById('shadow-value').textContent = e.target.value;
      if (testPreviewMode && testCreativeImg) drawPreview();
    });
    document.getElementById('config-lighting-adjustment').addEventListener('input', function(e) {
      document.getElementById('lighting-value').textContent = e.target.value;
    });
    document.getElementById('config-color-temperature').addEventListener('input', function(e) {
      document.getElementById('temperature-value').textContent = e.target.value;
    });
    document.getElementById('config-vignette').addEventListener('input', function(e) {
      document.getElementById('vignette-value').textContent = e.target.value;
      if (testPreviewMode && testCreativeImg) drawPreview();
    });

    // Test preview toggle
    document.getElementById('test-preview-toggle').addEventListener('change', function(e) {
      testPreviewMode = e.target.checked;
      const uploadSection = document.getElementById('test-preview-upload');
      uploadSection.style.display = testPreviewMode ? 'block' : 'none';

      if (!testPreviewMode) {
        // Turn off preview mode - clear test creative
        testCreativeImg = null;
      } else {
        // Turn on preview mode - reload image if file is already selected
        const fileInput = document.getElementById('test-creative-upload');
        const file = fileInput.files[0];
        if (file) {
          const reader = new FileReader();
          reader.onload = function(event) {
            const img = new Image();
            img.onload = function() {
              testCreativeImg = img;
              drawPreview();
            };
            img.src = event.target.result;
          };
          reader.readAsDataURL(file);
          return; // Skip drawPreview() below since it will be called after image loads
        }
      }

      drawPreview();
    });

    // Test creative upload
    document.getElementById('test-creative-upload').addEventListener('change', function(e) {
      const file = e.target.files[0];
      if (!file) return;

      const reader = new FileReader();
      reader.onload = function(event) {
        const img = new Image();
        img.onload = function() {
          testCreativeImg = img;
          drawPreview();
        };
        img.src = event.target.result;
      };
      reader.readAsDataURL(file);
    });

    // Manual detect green screen button
    document.getElementById('detect-greenscreen-btn').addEventListener('click', function() {
      if (!previewImg) return;

      // Draw image to a temp canvas for pixel analysis
      const tempCanvas = document.createElement('canvas');
      tempCanvas.width = previewImg.width;
      tempCanvas.height = previewImg.height;
      const tempCtx = tempCanvas.getContext('2d');
      tempCtx.drawImage(previewImg, 0, 0);
      const imageData = tempCtx.getImageData(0, 0, previewImg.width, previewImg.height);

      console.log('[Green Screen] Starting manual detection...');
      const detectedFrame = detectGreenScreen(imageData);
      if (detectedFrame) {
        currentPoints = detectedFrame;
        document.getElementById('add-frame-btn').disabled = false;
        document.getElementById('setup-hint').innerHTML =
          '‚úì Green screen detected! Frame auto-configured. Drag corners to adjust or click "Add Frame" to save.';

        // Show test preview section when frame is auto-detected
        document.getElementById('test-preview-section').style.display = 'block';

        console.log('[Green Screen] ‚úì Detection successful!');
        showMessage('Green screen detected successfully!', 'success');
      } else {
        document.getElementById('setup-hint').innerHTML =
          '‚ùå No green screen detected. Check console (F12) for details, try adjusting tolerance, or draw frame manually.';
        console.log('[Green Screen] ‚ùå Detection failed - see details above');
        showMessage('No green screen detected. Check console for details.', 'error');
      }

      drawPreview();
    });

    // Switch between modes
    function switchMode(mode) {
      currentMode = mode;

      document.querySelectorAll('.mode-btn').forEach(btn => btn.classList.remove('active'));
      event.target.classList.add('active');

      document.querySelectorAll('.section').forEach(section => section.classList.remove('active'));

      if (mode === 'setup') {
        document.getElementById('setup-section').classList.add('active');
        loadPhotoList();
      } else {
        document.getElementById('generate-section').classList.add('active');
      }
    }

    // Canvas drawing functions
    function clearCanvas() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.fillStyle = '#f8f9fa';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
    }

    function applyPerspectiveTransform(creative, points, canvasCtx) {
      // Simple perspective transform using canvas transform matrix
      // This is a basic implementation - for production use a proper perspective library
      const [tl, tr, br, bl] = points.map(pt => [drawX + pt[0] * scale, drawY + pt[1] * scale]);

      // Calculate the transformation
      canvasCtx.save();
      canvasCtx.beginPath();
      canvasCtx.moveTo(tl[0], tl[1]);
      canvasCtx.lineTo(tr[0], tr[1]);
      canvasCtx.lineTo(br[0], br[1]);
      canvasCtx.lineTo(bl[0], bl[1]);
      canvasCtx.closePath();
      canvasCtx.clip();

      // Draw creative stretched to fit the quadrilateral (simplified)
      const minX = Math.min(tl[0], tr[0], br[0], bl[0]);
      const minY = Math.min(tl[1], tr[1], br[1], bl[1]);
      const maxX = Math.max(tl[0], tr[0], br[0], bl[0]);
      const maxY = Math.max(tl[1], tr[1], br[1], bl[1]);

      canvasCtx.globalAlpha = 0.8;
      canvasCtx.drawImage(creative, minX, minY, maxX - minX, maxY - minY);
      canvasCtx.globalAlpha = 1.0;
      canvasCtx.restore();
    }

    function applyPerspectiveTransformWithConfig(creative, points, canvasCtx) {
      // Apply all config settings to preview - full opacity, realistic rendering
      const [tl, tr, br, bl] = points.map(pt => [drawX + pt[0] * scale, drawY + pt[1] * scale]);

      // Get config values
      const brightness = parseInt(document.getElementById('config-brightness').value) / 100;
      const contrast = parseInt(document.getElementById('config-contrast').value) / 100;
      const saturation = parseInt(document.getElementById('config-saturation').value) / 100;
      const vignette = parseInt(document.getElementById('config-vignette').value) / 100;
      const shadow = parseInt(document.getElementById('config-shadow-intensity').value) / 100;

      // Create offscreen canvas for image processing
      const tempCanvas = document.createElement('canvas');
      tempCanvas.width = creative.width;
      tempCanvas.height = creative.height;
      const tempCtx = tempCanvas.getContext('2d');
      tempCtx.drawImage(creative, 0, 0);

      // Apply brightness and contrast
      if (brightness !== 1 || contrast !== 1) {
        tempCtx.globalCompositeOperation = 'source-over';
        tempCtx.filter = `brightness(${brightness}) contrast(${contrast})`;
        tempCtx.drawImage(tempCanvas, 0, 0);
        tempCtx.filter = 'none';
      }

      // Apply saturation (simplified - canvas doesn't have direct saturation filter)
      if (saturation !== 1) {
        const imageData = tempCtx.getImageData(0, 0, tempCanvas.width, tempCanvas.height);
        const data = imageData.data;
        for (let i = 0; i < data.length; i += 4) {
          const r = data[i], g = data[i + 1], b = data[i + 2];
          const gray = 0.2989 * r + 0.5870 * g + 0.1140 * b;
          data[i] = gray + saturation * (r - gray);
          data[i + 1] = gray + saturation * (g - gray);
          data[i + 2] = gray + saturation * (b - gray);
        }
        tempCtx.putImageData(imageData, 0, 0);
      }

      // Apply vignette
      if (vignette > 0) {
        const gradient = tempCtx.createRadialGradient(
          tempCanvas.width / 2, tempCanvas.height / 2, 0,
          tempCanvas.width / 2, tempCanvas.height / 2, tempCanvas.width / 2
        );
        gradient.addColorStop(0, `rgba(0,0,0,0)`);
        gradient.addColorStop(1, `rgba(0,0,0,${vignette})`);
        tempCtx.fillStyle = gradient;
        tempCtx.fillRect(0, 0, tempCanvas.width, tempCanvas.height);
      }

      // Draw to main canvas
      canvasCtx.save();
      canvasCtx.beginPath();
      canvasCtx.moveTo(tl[0], tl[1]);
      canvasCtx.lineTo(tr[0], tr[1]);
      canvasCtx.lineTo(br[0], br[1]);
      canvasCtx.lineTo(bl[0], bl[1]);
      canvasCtx.closePath();
      canvasCtx.clip();

      const minX = Math.min(tl[0], tr[0], br[0], bl[0]);
      const minY = Math.min(tl[1], tr[1], br[1], bl[1]);
      const maxX = Math.max(tl[0], tr[0], br[0], bl[0]);
      const maxY = Math.max(tl[1], tr[1], br[1], bl[1]);

      // Full opacity for realistic preview
      canvasCtx.globalAlpha = 1.0;
      canvasCtx.drawImage(tempCanvas, minX, minY, maxX - minX, maxY - minY);

      // Apply shadow to edges if configured
      if (shadow > 0) {
        const shadowGradient = canvasCtx.createLinearGradient(minX, minY, maxX, maxY);
        shadowGradient.addColorStop(0, `rgba(0,0,0,${shadow * 0.5})`);
        shadowGradient.addColorStop(0.1, 'rgba(0,0,0,0)');
        shadowGradient.addColorStop(0.9, 'rgba(0,0,0,0)');
        shadowGradient.addColorStop(1, `rgba(0,0,0,${shadow * 0.5})`);
        canvasCtx.fillStyle = shadowGradient;
        canvasCtx.fillRect(minX, minY, maxX - minX, maxY - minY);
      }

      canvasCtx.restore();
    }

    function drawPreview() {
      clearCanvas();
      if (!previewImg) return;

      ctx.drawImage(previewImg, drawX, drawY, drawW, drawH);

      // If test creative is loaded in preview mode, show realistic mockup with config applied
      if (testCreativeImg && testPreviewMode) {
        const framesToPreview = currentPoints.length === 4 ? [currentPoints] : allFrames;
        framesToPreview.forEach(framePoints => {
          if (framePoints.length === 4) {
            applyPerspectiveTransformWithConfig(testCreativeImg, framePoints, ctx);
          }
        });
        // Skip drawing frame borders in test preview mode
        return;
      }

      // Draw all completed frames with grey fill and dashed edges with hard corners
      allFrames.forEach((framePoints, frameIndex) => {
        const isSelected = selectedFrameIndex === frameIndex;

        ctx.fillStyle = 'rgba(128, 128, 128, 0.3)'; // Grey semi-transparent fill
        ctx.strokeStyle = isSelected ? '#667eea' : '#333'; // Blue if selected, dark grey otherwise
        ctx.lineWidth = isSelected ? 4 : 3; // Thicker, bolder lines
        ctx.setLineDash([8, 4]); // Dashed lines
        ctx.lineCap = 'butt'; // Sharp/hard corners (not rounded)
        ctx.lineJoin = 'miter'; // Sharp corner joins

        ctx.beginPath();
        for (let i = 0; i < framePoints.length; i++) {
          const cx = drawX + framePoints[i][0] * scale;
          const cy = drawY + framePoints[i][1] * scale;
          if (i === 0) ctx.moveTo(cx, cy);
          else ctx.lineTo(cx, cy);
        }
        ctx.closePath();
        ctx.fill();
        ctx.stroke();
        ctx.setLineDash([]); // Reset dash

        // Draw small square corner markers for precision
        framePoints.forEach((pt, ptIndex) => {
          const cx = drawX + pt[0] * scale;
          const cy = drawY + pt[1] * scale;
          const markerSize = 8;

          ctx.fillStyle = isSelected ? '#667eea' : '#333';

          // Draw small square marker at corner
          ctx.fillRect(cx - markerSize/2, cy - markerSize/2, markerSize, markerSize);
        });
      });

      // Draw current frame being edited
      if (currentPoints.length > 0) {
        ctx.fillStyle = 'rgba(128, 128, 128, 0.3)'; // Grey semi-transparent fill
        ctx.strokeStyle = '#667eea'; // Blue outline for current editing
        ctx.lineWidth = 4; // Thick, bold line
        ctx.setLineDash([8, 4]); // Dashed line
        ctx.lineCap = 'butt'; // Sharp/hard corners
        ctx.lineJoin = 'miter'; // Sharp corner joins

        ctx.beginPath();
        currentPoints.forEach((pt, i) => {
          const cx = drawX + pt[0] * scale;
          const cy = drawY + pt[1] * scale;
          if (i === 0) ctx.moveTo(cx, cy);
          else ctx.lineTo(cx, cy);
        });
        if (currentPoints.length === 4) {
          ctx.closePath();
          ctx.fill();
        }
        ctx.stroke();
        ctx.setLineDash([]); // Reset dash

        // Draw small square corner markers
        currentPoints.forEach(pt => {
          const cx = drawX + pt[0] * scale;
          const cy = drawY + pt[1] * scale;
          const markerSize = 8;

          ctx.fillStyle = '#667eea';
          ctx.fillRect(cx - markerSize/2, cy - markerSize/2, markerSize, markerSize);
        });
      }
    }

    function fitImageIntoCanvas(imgW, imgH) {
      const s = Math.min(canvas.width / imgW, canvas.height / imgH);
      const w = Math.round(imgW * s);
      const h = Math.round(imgH * s);
      const x = Math.round((canvas.width - w) / 2);
      const y = Math.round((canvas.height - h) / 2);
      return { x, y, w, h, s };
    }

    // Detect green screen and extract actual corner coordinates (handles perspective/angled billboards)
    function detectGreenScreen(imageData) {
      const data = imageData.data;
      const width = imageData.width;
      const height = imageData.height;

      // Get target color from picker
      const targetHex = document.getElementById('greenscreen-color').value;
      const targetR = parseInt(targetHex.slice(1, 3), 16);
      const targetG = parseInt(targetHex.slice(3, 5), 16);
      const targetB = parseInt(targetHex.slice(5, 7), 16);

      // Color tolerance from slider
      const colorTolerance = parseInt(document.getElementById('color-tolerance').value);

      console.log(`[Green Screen] Target color: ${targetHex} (RGB: ${targetR}, ${targetG}, ${targetB}), Tolerance: ${colorTolerance}`);

      // Sample center pixel to help debug
      const centerIdx = (Math.floor(height / 2) * width + Math.floor(width / 2)) * 4;
      const sampleR = data[centerIdx];
      const sampleG = data[centerIdx + 1];
      const sampleB = data[centerIdx + 2];
      console.log(`[Green Screen] Sample pixel at center (RGB: ${sampleR}, ${sampleG}, ${sampleB})`);

      // Create binary mask of matching pixels
      const mask = new Uint8Array(width * height);
      let matchedPixelCount = 0;
      let minDistance = Infinity;
      let maxDistance = 0;

      for (let y = 0; y < height; y++) {
        for (let x = 0; x < width; x++) {
          const i = (y * width + x) * 4;
          const r = data[i];
          const g = data[i + 1];
          const b = data[i + 2];

          // Calculate Euclidean distance from target color
          const distance = Math.sqrt(
            Math.pow(r - targetR, 2) +
            Math.pow(g - targetG, 2) +
            Math.pow(b - targetB, 2)
          );

          minDistance = Math.min(minDistance, distance);
          maxDistance = Math.max(maxDistance, distance);

          // Check if within tolerance
          if (distance <= colorTolerance) {
            mask[y * width + x] = 255;
            matchedPixelCount++;
          } else {
            mask[y * width + x] = 0;
          }
        }
      }

      console.log(`[Green Screen] Distance range: ${minDistance.toFixed(1)} to ${maxDistance.toFixed(1)}`);

      console.log(`[Green Screen] Matched ${matchedPixelCount} pixels out of ${width * height} total`);
      console.log(`[Green Screen] Match percentage: ${(matchedPixelCount / (width * height) * 100).toFixed(2)}%`);

      if (matchedPixelCount < 1000) {
        console.log('[Green Screen] ‚ùå Not enough pixels matched (need at least 1000)');
        console.log('[Green Screen] Tip: Try increasing tolerance slider or check if green screen color matches');
        return null;
      }

      // Dilate (expand) the mask to extend green region outward
      const dilatedMask = new Uint8Array(width * height);
      // Expand detection slightly to catch edges
      const expandPixels = 3;

      for (let y = 0; y < height; y++) {
        for (let x = 0; x < width; x++) {
          const idx = y * width + x;
          let hasGreenNearby = false;

          for (let dy = -expandPixels; dy <= expandPixels; dy++) {
            for (let dx = -expandPixels; dx <= expandPixels; dx++) {
              const ny = y + dy;
              const nx = x + dx;
              if (ny >= 0 && ny < height && nx >= 0 && nx < width) {
                if (mask[ny * width + nx] === 255) {
                  hasGreenNearby = true;
                  break;
                }
              }
            }
            if (hasGreenNearby) break;
          }

          dilatedMask[idx] = hasGreenNearby ? 255 : 0;
        }
      }

      // Find contour points on the OUTSIDE edge of dilated region
      const contourPoints = [];

      for (let y = 1; y < height - 1; y++) {
        for (let x = 1; x < width - 1; x++) {
          const idx = y * width + x;
          if (dilatedMask[idx] === 0) {
            const hasDilatedNeighbor =
              dilatedMask[idx - 1] === 255 ||
              dilatedMask[idx + 1] === 255 ||
              dilatedMask[idx - width] === 255 ||
              dilatedMask[idx + width] === 255 ||
              dilatedMask[idx - width - 1] === 255 ||
              dilatedMask[idx - width + 1] === 255 ||
              dilatedMask[idx + width - 1] === 255 ||
              dilatedMask[idx + width + 1] === 255;

            if (hasDilatedNeighbor) {
              contourPoints.push([x, y]);
            }
          }
        }
      }

      console.log(`[Green Screen] Found ${contourPoints.length} contour points`);

      if (contourPoints.length < 4) {
        console.log('[Green Screen] ‚ùå Not enough contour points');
        return null;
      }

      // Find the 4 extreme corner points
      let topLeft = contourPoints[0];
      let topRight = contourPoints[0];
      let bottomRight = contourPoints[0];
      let bottomLeft = contourPoints[0];

      for (const pt of contourPoints) {
        const [x, y] = pt;
        if (x + y < topLeft[0] + topLeft[1]) topLeft = pt;
        if (x - y > topRight[0] - topRight[1]) topRight = pt;
        if (x + y > bottomRight[0] + bottomRight[1]) bottomRight = pt;
        if (x - y < bottomLeft[0] - bottomLeft[1]) bottomLeft = pt;
      }

      // Apply perspective-aware adaptive padding
      const topWidth = Math.abs(topRight[0] - topLeft[0]);
      const bottomWidth = Math.abs(bottomRight[0] - bottomLeft[0]);
      const leftHeight = Math.abs(bottomLeft[1] - topLeft[1]);
      const rightHeight = Math.abs(bottomRight[1] - topRight[1]);

      const widthRatio = topWidth / bottomWidth;
      const heightRatio = leftHeight / rightHeight;

      console.log(`[Green Screen] Perspective - Width ratio: ${widthRatio.toFixed(2)}, Height ratio: ${heightRatio.toFixed(2)}`);

      // Adaptive padding based on perspective distortion (depth perception effect)
      // Smaller sides indicate greater depth/distance, requiring more padding
      // Get depth multiplier from config slider
      const depthMultiplier = parseInt(document.getElementById('config-depth-multiplier').value);

      if (widthRatio > 1.1) {
        // Top wider: bottom recedes (further away), push bottom out more
        const extra = Math.floor((widthRatio - 1) * depthMultiplier);
        bottomLeft[1] = Math.min(height - 1, bottomLeft[1] + extra);
        bottomRight[1] = Math.min(height - 1, bottomRight[1] + extra);
        console.log(`[Green Screen] +${extra}px bottom (depth: ${widthRatio.toFixed(2)}x)`);
      } else if (widthRatio < 0.9) {
        // Bottom wider: top recedes (further away), push top out more
        const extra = Math.floor((1 / widthRatio - 1) * depthMultiplier);
        topLeft[1] = Math.max(0, topLeft[1] - extra);
        topRight[1] = Math.max(0, topRight[1] - extra);
        console.log(`[Green Screen] +${extra}px top (depth: ${(1/widthRatio).toFixed(2)}x)`);
      }

      if (heightRatio > 1.1) {
        // Left taller: right recedes (further away), push right out more
        const extra = Math.floor((heightRatio - 1) * depthMultiplier);
        topRight[0] = Math.min(width - 1, topRight[0] + extra);
        bottomRight[0] = Math.min(width - 1, bottomRight[0] + extra);
        console.log(`[Green Screen] +${extra}px right (depth: ${heightRatio.toFixed(2)}x)`);
      } else if (heightRatio < 0.9) {
        // Right taller: left recedes (further away), push left out more
        const extra = Math.floor((1 / heightRatio - 1) * depthMultiplier);
        topLeft[0] = Math.max(0, topLeft[0] - extra);
        bottomLeft[0] = Math.max(0, bottomLeft[0] - extra);
        console.log(`[Green Screen] +${extra}px left (depth: ${(1/heightRatio).toFixed(2)}x)`);
      }

      console.log(`[Green Screen] ‚úì Corners:`, {topLeft, topRight, bottomRight, bottomLeft});

      return [topLeft, topRight, bottomRight, bottomLeft];
    }

    // Handle photo upload
    document.getElementById('billboard-photo').addEventListener('change', function(e) {
      const file = e.target.files[0];
      if (!file) return;

      currentPhoto = file;
      const reader = new FileReader();
      reader.onload = function(event) {
        const img = new Image();
        img.onload = function() {
          previewImg = img;
          imgNaturalW = img.width;
          imgNaturalH = img.height;

          const fit = fitImageIntoCanvas(imgNaturalW, imgNaturalH);
          drawX = fit.x;
          drawY = fit.y;
          drawW = fit.w;
          drawH = fit.h;
          scale = fit.s;

          currentPoints = [];

          // Enable detect button when image is loaded
          if (document.getElementById('greenscreen-toggle').checked) {
            document.getElementById('detect-greenscreen-btn').disabled = false;
            document.getElementById('setup-hint').innerHTML =
              'Click "Detect Green Screen Now" button to find the frame, or draw manually';
          } else {
            document.getElementById('setup-hint').innerHTML =
              'Click and drag to draw a box around the billboard screen';
          }

          drawPreview();
        };
        img.src = event.target.result;
      };
      reader.readAsDataURL(file);
    });

    // Handle canvas drag for drawing boxes and editing corners
    let isDrawing = false;
    let isDraggingCorner = false;
    let isDraggingFrame = false;
    let dragFrameIndex = -1;
    let dragPointIndex = -1;
    let selectedFrameIndex = -1;
    let startX, startY;
    let dragOffsetX = 0;
    let dragOffsetY = 0;

    function getClickedCorner(x, y) {
      const hitRadius = 15;

      // Check current frame first
      if (currentPoints.length > 0) {
        for (let i = 0; i < currentPoints.length; i++) {
          const cx = drawX + currentPoints[i][0] * scale;
          const cy = drawY + currentPoints[i][1] * scale;
          const dist = Math.sqrt((x - cx) ** 2 + (y - cy) ** 2);
          if (dist < hitRadius) {
            return { frame: -1, point: i }; // -1 means current frame
          }
        }
      }

      // Check all saved frames
      for (let fi = 0; fi < allFrames.length; fi++) {
        for (let pi = 0; pi < allFrames[fi].length; pi++) {
          const cx = drawX + allFrames[fi][pi][0] * scale;
          const cy = drawY + allFrames[fi][pi][1] * scale;
          const dist = Math.sqrt((x - cx) ** 2 + (y - cy) ** 2);
          if (dist < hitRadius) {
            return { frame: fi, point: pi };
          }
        }
      }
      return null;
    }

    function isPointInFrame(x, y, framePoints) {
      // Check if point is inside polygon using ray casting
      const imgX = (x - drawX) / scale;
      const imgY = (y - drawY) / scale;

      let inside = false;
      for (let i = 0, j = framePoints.length - 1; i < framePoints.length; j = i++) {
        const xi = framePoints[i][0], yi = framePoints[i][1];
        const xj = framePoints[j][0], yj = framePoints[j][1];

        const intersect = ((yi > imgY) !== (yj > imgY))
            && (imgX < (xj - xi) * (imgY - yi) / (yj - yi) + xi);
        if (intersect) inside = !inside;
      }
      return inside;
    }

    function getHoveredFrame(x, y) {
      // Check current frame first
      if (currentPoints.length === 4 && isPointInFrame(x, y, currentPoints)) {
        return -1;
      }

      // Check all saved frames
      for (let fi = allFrames.length - 1; fi >= 0; fi--) {
        if (isPointInFrame(x, y, allFrames[fi])) {
          return fi;
        }
      }
      return null;
    }

    canvas.addEventListener('mousedown', function(e) {
      if (currentMode !== 'setup' || !previewImg) return;

      const rect = canvas.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;

      // Shift+Click to detect color at clicked point
      if (e.shiftKey) {
        // Check if click is inside image
        if (x < drawX || y < drawY || x > drawX + drawW || y > drawY + drawH) return;

        // Get pixel color from image
        const ix = Math.floor((x - drawX) / scale);
        const iy = Math.floor((y - drawY) / scale);

        const tempCanvas = document.createElement('canvas');
        tempCanvas.width = previewImg.width;
        tempCanvas.height = previewImg.height;
        const tempCtx = tempCanvas.getContext('2d');
        tempCtx.drawImage(previewImg, 0, 0);
        const imageData = tempCtx.getImageData(ix, iy, 1, 1);
        const r = imageData.data[0];
        const g = imageData.data[1];
        const b = imageData.data[2];
        const hex = '#' + [r, g, b].map(v => v.toString(16).padStart(2, '0')).join('').toUpperCase();

        console.log(`[Color Picker] Clicked at (${ix}, ${iy}): RGB(${r}, ${g}, ${b}) = ${hex}`);

        // Optionally set it as the target color
        document.getElementById('greenscreen-color').value = hex;
        document.getElementById('greenscreen-color-hex').value = hex;

        showMessage(`Color detected: ${hex} (RGB: ${r}, ${g}, ${b})`, 'success');
        return;
      }

      // Check if clicking on a corner (highest priority)
      const corner = getClickedCorner(x, y);
      if (corner) {
        isDraggingCorner = true;
        dragFrameIndex = corner.frame;
        dragPointIndex = corner.point;
        if (dragFrameIndex >= 0) {
          selectedFrameIndex = dragFrameIndex;
        }
        drawPreview();
        return;
      }

      // Check if clicking inside a frame (to drag entire frame)
      const hoveredFrame = getHoveredFrame(x, y);
      if (hoveredFrame !== null) {
        isDraggingFrame = true;
        dragFrameIndex = hoveredFrame;
        selectedFrameIndex = hoveredFrame;
        startX = x;
        startY = y;
        canvas.style.cursor = 'move';
        drawPreview();
        return;
      }

      // Check if click is inside image
      if (x < drawX || y < drawY || x > drawX + drawW || y > drawY + drawH) return;

      // Start drawing new box
      isDrawing = true;
      startX = x;
      startY = y;
      selectedFrameIndex = -1;
    });

    canvas.addEventListener('mousemove', function(e) {
      if (currentMode !== 'setup' || !previewImg) return;

      const rect = canvas.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;

      // Dragging a corner
      if (isDraggingCorner) {
        const ix = (x - drawX) / scale;
        const iy = (y - drawY) / scale;

        if (dragFrameIndex === -1) {
          // Editing current frame
          currentPoints[dragPointIndex] = [Math.round(ix), Math.round(iy)];
        } else {
          // Editing saved frame
          allFrames[dragFrameIndex][dragPointIndex] = [Math.round(ix), Math.round(iy)];
        }
        drawPreview();
        return;
      }

      // Dragging entire frame
      if (isDraggingFrame) {
        const deltaX = (x - startX) / scale;
        const deltaY = (y - startY) / scale;

        if (dragFrameIndex === -1) {
          // Move current frame
          currentPoints = currentPoints.map(pt => [
            Math.round(pt[0] + deltaX),
            Math.round(pt[1] + deltaY)
          ]);
        } else {
          // Move saved frame
          allFrames[dragFrameIndex] = allFrames[dragFrameIndex].map(pt => [
            Math.round(pt[0] + deltaX),
            Math.round(pt[1] + deltaY)
          ]);
        }

        startX = x;
        startY = y;
        drawPreview();
        return;
      }

      // Drawing new box
      if (isDrawing) {
        drawPreview();
        const ctx = canvas.getContext('2d');

        // Draw grey fill
        ctx.fillStyle = 'rgba(128, 128, 128, 0.3)';
        const width = x - startX;
        const height = y - startY;
        ctx.fillRect(startX, startY, width, height);

        // Draw dashed outline with hard corners
        ctx.strokeStyle = '#667eea';
        ctx.lineWidth = 4;
        ctx.setLineDash([8, 4]);
        ctx.lineCap = 'butt';
        ctx.lineJoin = 'miter';
        ctx.strokeRect(startX, startY, width, height);
        ctx.setLineDash([]);
        return;
      }

      // Update cursor based on hover state
      const hoveredFrame = getHoveredFrame(x, y);
      const hoveredCorner = getClickedCorner(x, y);

      if (hoveredCorner) {
        canvas.style.cursor = 'pointer';
      } else if (hoveredFrame !== null) {
        canvas.style.cursor = 'move';
      } else {
        canvas.style.cursor = 'crosshair';
      }
    });

    canvas.addEventListener('mouseup', function(e) {
      if (currentMode !== 'setup' || !previewImg) return;

      if (isDraggingCorner) {
        isDraggingCorner = false;
        dragFrameIndex = -1;
        dragPointIndex = -1;
        canvas.style.cursor = 'crosshair';
        drawPreview();
        return;
      }

      if (isDraggingFrame) {
        isDraggingFrame = false;
        dragFrameIndex = -1;
        canvas.style.cursor = 'crosshair';
        drawPreview();
        return;
      }

      if (!isDrawing) return;

      const rect = canvas.getBoundingClientRect();
      const endX = e.clientX - rect.left;
      const endY = e.clientY - rect.top;

      const topLeftX = (Math.min(startX, endX) - drawX) / scale;
      const topLeftY = (Math.min(startY, endY) - drawY) / scale;
      const bottomRightX = (Math.max(startX, endX) - drawX) / scale;
      const bottomRightY = (Math.max(startY, endY) - drawY) / scale;

      currentPoints = [
        [Math.round(topLeftX), Math.round(topLeftY)],
        [Math.round(bottomRightX), Math.round(topLeftY)],
        [Math.round(bottomRightX), Math.round(bottomRightY)],
        [Math.round(topLeftX), Math.round(bottomRightY)]
      ];

      isDrawing = false;
      drawPreview();

      document.getElementById('add-frame-btn').disabled = false;
      document.getElementById('setup-hint').innerHTML =
        '‚úì Frame drawn! Drag corners to adjust, or drag inside to move. Click "Add Frame" to save.';

      // Show test preview section when frame is drawn (blue state)
      document.getElementById('test-preview-section').style.display = 'block';
    });

    // Add current frame to allFrames
    function addFrame() {
      if (currentPoints.length !== 4) {
        showMessage('Please select 4 corner points', 'error');
        return;
      }

      allFrames.push([...currentPoints]);
      currentPoints = [];
      document.getElementById('add-frame-btn').disabled = true;
      document.getElementById('save-all-btn').disabled = false;
      document.getElementById('frames-info').style.display = 'block';
      document.getElementById('frame-count').textContent = allFrames.length;

      document.getElementById('setup-hint').innerHTML =
        `‚úì Frame ${allFrames.length} added! Draw another box for more frames, or "Save All Frames" when done.`;

      // Hide test preview section and clear preview when frame is added
      document.getElementById('test-preview-section').style.display = 'none';
      document.getElementById('test-preview-toggle').checked = false;
      testPreviewMode = false;
      testCreativeImg = null;
      document.getElementById('test-preview-upload').style.display = 'none';
      document.getElementById('test-creative-upload').value = '';

      drawPreview();
    }

    // Reset current frame
    function resetCurrentFrame() {
      currentPoints = [];

      // Hide test preview section when frame is reset
      document.getElementById('test-preview-section').style.display = 'none';
      document.getElementById('test-preview-toggle').checked = false;
      testPreviewMode = false;
      testCreativeImg = null;
      document.getElementById('test-preview-upload').style.display = 'none';
      document.getElementById('test-creative-upload').value = '';

      drawPreview();
      document.getElementById('add-frame-btn').disabled = true;
      if (previewImg) {
        if (allFrames.length > 0) {
          document.getElementById('setup-hint').innerHTML =
            `${allFrames.length} frame(s) saved. Draw another box for another frame, or "Save All Frames" when done.`;
        } else {
          document.getElementById('setup-hint').innerHTML =
            'Click and drag to draw a box around the billboard screen';
        }
      }
    }

    // Clear all frames
    function clearAllFrames() {
      if (allFrames.length === 0 && currentPoints.length === 0) return;
      if (!confirm('Clear all frames? This will reset your work.')) return;

      allFrames = [];
      currentPoints = [];
      document.getElementById('add-frame-btn').disabled = true;
      document.getElementById('save-all-btn').disabled = true;
      document.getElementById('frames-info').style.display = 'none';
      document.getElementById('frame-count').textContent = '0';
      drawPreview();

      if (previewImg) {
        document.getElementById('setup-hint').innerHTML =
          'Click and drag to draw a box around the billboard screen';
      }
    }

    // Save all frames
    async function saveAllFrames() {
      const locationKey = document.getElementById('setup-location').value;
      const timeOfDay = document.getElementById('setup-time-of-day').value;
      const finish = document.getElementById('setup-finish').value;

      if (!locationKey) {
        showMessage('Please select a location', 'error');
        return;
      }

      // Add current frame if it has 4 points
      if (currentPoints.length === 4) {
        allFrames.push([...currentPoints]);
        currentPoints = [];
      }

      if (allFrames.length === 0) {
        showMessage('Please add at least one frame', 'error');
        return;
      }

      if (!currentPhoto) {
        showMessage('Please upload a photo', 'error');
        return;
      }

      // Collect config values
      const config = {
        brightness: parseInt(document.getElementById('config-brightness').value),
        contrast: parseInt(document.getElementById('config-contrast').value),
        saturation: parseInt(document.getElementById('config-saturation').value),
        depthMultiplier: parseInt(document.getElementById('config-depth-multiplier').value),
        blurStrength: parseInt(document.getElementById('config-blur-strength').value),
        overlayOpacity: parseInt(document.getElementById('config-overlay-opacity').value),
        shadowIntensity: parseInt(document.getElementById('config-shadow-intensity').value),
        lightingAdjustment: parseInt(document.getElementById('config-lighting-adjustment').value),
        colorTemperature: parseInt(document.getElementById('config-color-temperature').value),
        vignette: parseInt(document.getElementById('config-vignette').value)
      };

      const formData = new FormData();
      formData.append('location_key', locationKey);
      formData.append('time_of_day', timeOfDay);
      formData.append('finish', finish);
      formData.append('photo', currentPhoto);
      formData.append('frames_data', JSON.stringify(allFrames));
      formData.append('config_json', JSON.stringify(config));

      try {
        const response = await fetch('/api/mockup/save-frame', {
          method: 'POST',
          body: formData
        });

        const result = await response.json();

        if (response.ok) {
          showMessage(`Saved ${allFrames.length} frame(s) successfully!`, 'success');
          clearAllFrames();
          document.getElementById('billboard-photo').value = '';
          previewImg = null;
          currentPhoto = null;
          loadPhotoList();
        } else {
          showMessage(result.error || 'Failed to save frames', 'error');
        }
      } catch (err) {
        showMessage('Network error: ' + err.message, 'error');
      }
    }

    // Load photo list
    async function loadPhotoList() {
      const locationKey = document.getElementById('setup-location').value;
      if (!locationKey) {
        document.getElementById('photo-list').innerHTML = '';
        return;
      }

      try {
        const response = await fetch(`/api/mockup/photos/${locationKey}`);
        const data = await response.json();

        const photoList = document.getElementById('photo-list');
        if (!data.photos || data.photos.length === 0) {
          photoList.innerHTML = '<p style="grid-column: 1/-1; text-align: center; color: #6c757d;">No photos configured for this location yet.</p>';
          return;
        }

        photoList.innerHTML = data.photos.map(photo => `
          <div class="photo-card">
            <img src="/api/mockup/photo/${locationKey}/${photo}" alt="${photo}">
            <div class="photo-card-info">
              <h4>${photo}</h4>
              <button class="btn btn-danger btn-sm" onclick="deletePhoto('${locationKey}', '${photo}')">Delete</button>
            </div>
          </div>
        `).join('');
      } catch (err) {
        showMessage('Failed to load photos', 'error');
      }
    }

    // Delete photo
    async function deletePhoto(locationKey, photoFilename) {
      if (!confirm(`Delete ${photoFilename}?`)) return;

      try {
        const response = await fetch(`/api/mockup/photo/${locationKey}/${photoFilename}`, {
          method: 'DELETE'
        });

        if (response.ok) {
          showMessage('Photo deleted successfully', 'success');
          loadPhotoList();
        } else {
          const result = await response.json();
          showMessage(result.error || 'Failed to delete photo', 'error');
        }
      } catch (err) {
        showMessage('Network error: ' + err.message, 'error');
      }
    }

    // Generate mockup
    async function generateMockup() {
      const locationKey = document.getElementById('generate-location').value;
      const timeOfDay = document.getElementById('generate-time-of-day').value;
      const finish = document.getElementById('generate-finish').value;
      const creativeFile = document.getElementById('creative-photo').files[0];
      const aiPrompt = document.getElementById('ai-creative-prompt').value.trim();

      if (!locationKey) {
        showMessage('Please select a location', 'error');
        return;
      }

      if (!creativeFile && !aiPrompt) {
        showMessage('Please either upload a creative image OR provide an AI prompt', 'error');
        return;
      }

      const formData = new FormData();
      formData.append('location_key', locationKey);
      formData.append('time_of_day', timeOfDay);
      formData.append('finish', finish);

      // If AI prompt is provided, use AI mode (ignore uploaded file)
      if (aiPrompt) {
        formData.append('ai_prompt', aiPrompt);
      } else {
        formData.append('creative', creativeFile);
      }

      document.getElementById('loading').classList.add('active');
      document.getElementById('generate-btn').disabled = true;
      document.getElementById('mockup-result').innerHTML = '';

      try {
        const response = await fetch('/api/mockup/generate', {
          method: 'POST',
          body: formData
        });

        if (response.ok) {
          const blob = await response.blob();
          const url = URL.createObjectURL(blob);

          document.getElementById('mockup-result').innerHTML = `
            <h3 style="margin-bottom: 15px;">Generated Mockup</h3>
            <img src="${url}" alt="Generated Mockup">
            <div style="margin-top: 15px;">
              <a href="${url}" download="mockup.jpg" class="btn btn-primary">Download Mockup</a>
            </div>
          `;
          showMessage('Mockup generated successfully!', 'success');
        } else {
          const result = await response.json();
          showMessage(result.error || 'Failed to generate mockup', 'error');
        }
      } catch (err) {
        showMessage('Network error: ' + err.message, 'error');
      } finally {
        document.getElementById('loading').classList.remove('active');
        document.getElementById('generate-btn').disabled = false;
      }
    }

    // Show message
    function showMessage(text, type) {
      const messageEl = document.getElementById('message');
      messageEl.textContent = text;
      messageEl.className = `message ${type}`;

      setTimeout(() => {
        messageEl.className = 'message';
      }, 5000);
    }

    // Event listeners
    document.getElementById('setup-location').addEventListener('change', loadPhotoList);

    // Update generate button state when either upload or AI prompt changes
    function updateGenerateButtonState() {
      const hasFile = document.getElementById('creative-photo').files.length > 0;
      const hasPrompt = document.getElementById('ai-creative-prompt').value.trim().length > 0;
      const hasLocation = document.getElementById('generate-location').value !== '';
      document.getElementById('generate-btn').disabled = !hasLocation || (!hasFile && !hasPrompt);
    }

    document.getElementById('creative-photo').addEventListener('change', updateGenerateButtonState);
    document.getElementById('ai-creative-prompt').addEventListener('input', updateGenerateButtonState);
    document.getElementById('generate-location').addEventListener('change', updateGenerateButtonState);

    // Initialize
    loadLocations();
  </script>
</body>
</html>
